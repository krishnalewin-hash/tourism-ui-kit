// Async Client Configuration Loader
// This module handles loading client-specific configurations before initializing the form

window.BookingForm = window.BookingForm || {};

// Add missing applyPlaceholderClass for passenger select styling
window.BookingForm.applyPlaceholderClass = function(el) {
  if (!el) return;
  if (el.value === '' || el.value === null) {
    el.classList.add('is-placeholder');
  } else {
    el.classList.remove('is-placeholder');
  }
};

// Add missing matchFieldLook for passenger select styling
window.BookingForm.matchFieldLook = function(field) {
  if (!field) return;
  var ref = document.querySelector('.icon-field-wrapper input[data-q]') || document.querySelector('input[data-q]');
  if (!ref) return;
  var cs = window.getComputedStyle(ref);
  field.style.borderRadius = cs.borderRadius;
  field.style.boxShadow = cs.boxShadow;
  field.style.borderColor = cs.borderColor;
  field.style.fontFamily = cs.fontFamily;
  field.style.fontSize = cs.fontSize;
  field.style.background = cs.background;
  field.style.color = cs.color;
};

// Configuration loader with built-in fallbacks
async function loadClientConfiguration() {
  console.log('[ConfigLoader] Starting configuration loading...');
  
  // If config is already complete, skip loading
  if (window.CFG?.GMAPS_KEY && window.CFG?.configLoaded) {
    console.log('[ConfigLoader] Using pre-loaded configuration');
    return window.CFG;
  }

  // Determine client from various sources
  const client = window.CFG?.client || 
                new URLSearchParams(location.search).get('client') || 
                sessionStorage.getItem('client') || 
                'tour-driver';

  // Determine base URL for configs
  const base = window.CFG?.base || 'krishnalewin-hash/tourism-ui-kit@main';

  console.log(`[ConfigLoader] Loading configuration for client: ${client}`);
  console.log(`[ConfigLoader] Base URL: ${base}`);

  try {
    // Try to load core configuration first
    let configUrl;
    if (base.startsWith('../') || base.startsWith('./') || base.startsWith('/')) {
      configUrl = `${base}/clients/${client}/core/config.json`;
    } else {
      configUrl = `https://cdn.jsdelivr.net/gh/${base}/clients/${client}/core/config.json`;
    }

    console.log(`[ConfigLoader] Fetching: ${configUrl}`);
    
    const response = await fetch(configUrl, { cache: 'no-store' });
    if (response.ok) {
      const clientConfig = await response.json();
      
      // Merge client configuration
      window.CFG = {
        ...window.CFG,
        ...clientConfig.FORM_CONFIG,
        // Flatten commonly used properties
        GMAPS_KEY: clientConfig.FORM_CONFIG?.GMAPS_KEY,
        COUNTRIES: clientConfig.FORM_CONFIG?.COUNTRIES,
        CURRENCY: clientConfig.FORM_CONFIG?.CURRENCY,
        PLACES: clientConfig.FORM_CONFIG?.PLACES,
        FIELD_MAPPING: clientConfig.FORM_CONFIG?.FIELD_MAPPING,
        configLoaded: true,
        loadedFrom: 'core-config'
      };

      console.log(`[ConfigLoader] Successfully loaded ${client} configuration from core config`);
      return window.CFG;
    } else {
      console.log(`[ConfigLoader] Core config returned ${response.status}: ${response.statusText}`);
    }
  } catch (error) {
    console.log(`[ConfigLoader] Core config fetch failed: ${error.message}`);
  }

  // Fallback: Try legacy single file
  try {
    let legacyUrl;
    if (base.startsWith('../') || base.startsWith('./') || base.startsWith('/')) {
      legacyUrl = `${base}/clients/${client}.json`;
    } else {
      legacyUrl = `https://cdn.jsdelivr.net/gh/${base}/clients/${client}.json`;
    }

    console.log(`[ConfigLoader] Trying legacy config: ${legacyUrl}`);
    
    const response = await fetch(legacyUrl, { cache: 'no-store' });
    if (response.ok) {
      const clientConfig = await response.json();
      
      window.CFG = {
        ...window.CFG,
        ...clientConfig.FORM_CONFIG,
        GMAPS_KEY: clientConfig.FORM_CONFIG?.GMAPS_KEY,
        COUNTRIES: clientConfig.FORM_CONFIG?.COUNTRIES,
        CURRENCY: clientConfig.FORM_CONFIG?.CURRENCY,
        PLACES: clientConfig.FORM_CONFIG?.PLACES,
        FIELD_MAPPING: clientConfig.FORM_CONFIG?.FIELD_MAPPING,
        configLoaded: true,
        loadedFrom: 'legacy-config'
      };

      console.log(`[ConfigLoader] Successfully loaded ${client} configuration from legacy config`);
      return window.CFG;
    } else {
      console.log(`[ConfigLoader] Legacy config returned ${response.status}: ${response.statusText}`);
    }
  } catch (error) {
    console.log(`[ConfigLoader] Legacy config fetch failed: ${error.message}`);
  }

  // Final fallback: Use defaults with demo API key
  console.warn(`[ConfigLoader] No configuration found for ${client}, using defaults`);
  
  window.CFG = {
    ...window.CFG,
    GMAPS_KEY: window.CFG?.GMAPS_KEY || 'AIzaSyBdVl-cGl0fhXhhD_x5RCJxWQQyzVF0z8g', // Demo fallback
    COUNTRIES: window.CFG?.COUNTRIES || ['jm'],
    CURRENCY: window.CFG?.CURRENCY || 'USD',
    PLACES: {
      FIELDS: ['place_id', 'formatted_address', 'geometry', 'name', 'types'],
      TYPES: ['establishment'],
      ...(window.CFG?.PLACES || {})
    },
    configLoaded: true,
    loadedFrom: 'defaults'
  };

  return window.CFG;
}

// Detect if we're on a tour detail page and apply appropriate settings
function detectTourPageContext() {
  console.log('[TourDetection] Analyzing page context...');
  
  // Priority 1: Manual configuration (bulletproof)
  const manualConfig = window.CFG?.formType === 'tour';
  const dataAttribute = document.body?.getAttribute('data-booking-form') === 'tour' ||
                       document.documentElement?.getAttribute('data-booking-form') === 'tour' ||
                       !!document.querySelector('[data-booking-form="tour"]');
  
  if (manualConfig) {
    console.log('[TourDetection] ✓ MANUAL CONFIG: formType = "tour"');
  }
  
  if (dataAttribute) {
    console.log('[TourDetection] ✓ DATA ATTRIBUTE: data-booking-form="tour" found');
  }
  
  // If manual config exists, use it (bulletproof)
  if (manualConfig || dataAttribute) {
    const isTourPage = true;
    console.log('[TourDetection] Result: TOUR PAGE (manual configuration)');
    
    // Apply tour-specific configuration
    window.CFG = {
      ...window.CFG,
      hideDropoff: true,
      stickyForm: true,
      prefillDropoff: true,
      tourPageDetected: true
    };
    
    console.log('[TourDetection] Applied tour page settings');
    return isTourPage;
  }
  
  // Priority 2: Automatic detection (fallback for existing implementations)
  const detectionMethods = {
    url: /\/(tour|experience|activity|destination)/i.test(window.location.pathname),
    pageTitle: /tour|experience|activity|excursion/i.test(document.title),
    metaTags: !!document.querySelector('meta[name*="tour"], meta[property*="tour"], meta[content*="tour" i]'),
    dataAttributes: !!document.querySelector('[data-tour], [data-experience], [data-activity]'),
    headings: !!document.querySelector('h1, h2, h3')?.textContent?.match(/tour|experience|activity|excursion/i),
    pageContent: document.body.textContent.toLowerCase().includes('tour detail') || 
                document.body.textContent.toLowerCase().includes('book this tour')
  };
  
  // Count positive detections
  const detections = Object.entries(detectionMethods).filter(([method, detected]) => {
    if (detected) console.log(`[TourDetection] ✓ Detected via ${method}`);
    return detected;
  });
  
  const isTourPage = detections.length >= 2; // Require at least 2 positive detections
  
  console.log(`[TourDetection] Result: ${isTourPage ? 'TOUR PAGE' : 'AIRPORT TRANSFER PAGE'} (${detections.length}/6 automatic methods)`);
  
  if (isTourPage) {
    // Apply tour-specific configuration
    window.CFG = {
      ...window.CFG,
      hideDropoff: true,
      stickyForm: true,
      prefillDropoff: true,
      tourPageDetected: true
    };
    
    console.log('[TourDetection] Applied tour page settings');
  }
  
  return isTourPage;
}

// Apply tour-specific behaviors when on a tour page
function applyTourPageBehavior() {
  console.log('[TourBehavior] Applying tour page enhancements...');
  
  // Apply CSS classes to body for tour-specific styling (idempotent)
  if (window.CFG.hideDropoff && !document.body.classList.contains('tour-page-hide-dropoff')) {
    document.body.classList.add('tour-page-hide-dropoff');
    console.log('[TourBehavior] ✓ Hide dropoff field enabled');
    
    // Inject critical CSS immediately without relying on inject function
    if (!document.getElementById('tour-critical-styles')) {
      const style = document.createElement('style');
      style.id = 'tour-critical-styles';
      style.textContent = `
        /* Hide drop-off input fields */
        .tour-page-hide-dropoff [data-name="dropoff_location"],
        .tour-page-hide-dropoff [name="dropoff_location"],
        body.tour-page-hide-dropoff [data-name="dropoff_location"],
        body.tour-page-hide-dropoff [name="dropoff_location"] {
          display: none !important;
          visibility: hidden !important;
          height: 0 !important;
          margin: 0 !important;
          padding: 0 !important;
        }
        /* Hide parent containers */
        .tour-page-hide-dropoff .ghl-form-row:has([data-name="dropoff_location"]),
        .tour-page-hide-dropoff .ghl-form-row:has([name="dropoff_location"]),
        body.tour-page-hide-dropoff .ghl-form-row:has([data-name="dropoff_location"]),
        body.tour-page-hide-dropoff .ghl-form-row:has([name="dropoff_location"]) {
          display: none !important;
        }
        /* Hide specific div ID that contains drop-off field */
        .tour-page-hide-dropoff #el_pmkaWAYqmvey4VusfPvF_Ff2mstR1InquK2d7G2hX_2,
        body.tour-page-hide-dropoff #el_pmkaWAYqmvey4VusfPvF_Ff2mstR1InquK2d7G2hX_2 {
          display: none !important;
          visibility: hidden !important;
          height: 0 !important;
          margin: 0 !important;
          padding: 0 !important;
        }
        /* Remove padding from survey form */
        .survey-2xXWpyyoCV .hl_form-builder--main {
          padding: 0px !important;
        }
      `;
      document.head.appendChild(style);
      console.log('[TourBehavior] ✓ Critical tour styles injected immediately');
    }
  }
  
  if (window.CFG.stickyForm && !document.body.classList.contains('tour-page-sticky-form')) {
    document.body.classList.add('tour-page-sticky-form');
    console.log('[TourBehavior] ✓ Sticky form positioning enabled');
    
    // Inject sticky CSS immediately
    if (!document.getElementById('tour-sticky-styles')) {
      const style = document.createElement('style');
      style.id = 'tour-sticky-styles';
      style.textContent = `
        /* Sticky form - multiple selectors for maximum override */
        .tour-page-sticky-form #_builder-form,
        body.tour-page-sticky-form #_builder-form,
        .tour-page-sticky-form .hl_form-builder,
        body.tour-page-sticky-form .hl_form-builder,
        .tour-page-sticky-form .survey-2xXWpyyoCV,
        body.tour-page-sticky-form .survey-2xXWpyyoCV {
          position: sticky !important;
          top: 20px !important;
          z-index: 1000 !important;
          background: white !important;
          border-radius: 8px !important;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06) !important;
          padding: 10px !important;
          max-height: calc(100vh - 40px) !important;
          overflow-y: auto !important;
          margin-bottom: 20px !important;
        }
        
        /* Form builder main container - no padding */
        .tour-page-sticky-form .hl_form-builder--main,
        body.tour-page-sticky-form .hl_form-builder--main {
          padding: 0px !important;
        }
        
        @media (max-width: 768px) {
          .tour-page-sticky-form #_builder-form,
          body.tour-page-sticky-form #_builder-form,
          .tour-page-sticky-form .hl_form-builder,
          body.tour-page-sticky-form .hl_form-builder,
          .tour-page-sticky-form .survey-2xXWpyyoCV,
          body.tour-page-sticky-form .survey-2xXWpyyoCV,
          .tour-page-sticky-form .hl_form-builder--main,
          body.tour-page-sticky-form .hl_form-builder--main {
            position: relative !important;
            top: auto !important;
            margin: 20px 0 !important;
          }
        }
        
        /* Ensure passenger dropdown works with sticky form */
        .tour-page-sticky-form .passenger-dropdown,
        .tour-page-sticky-form .passenger-popup,
        body.tour-page-sticky-form .passenger-dropdown,
        body.tour-page-sticky-form .passenger-popup {
          z-index: 10000 !important;
          position: relative !important;
        }
      `;
      document.head.appendChild(style);
      console.log('[TourBehavior] ✓ Sticky form styles injected immediately');
    }
  }
  
  // Also try to inject with the proper function if available (for completeness)
  if (window.BookingForm.injectTourStyles) {
    window.BookingForm.injectTourStyles();
  } else {
    // Defer until inject function is available
    setTimeout(() => {
      if (window.BookingForm.injectTourStyles) {
        window.BookingForm.injectTourStyles();
        console.log('[TourBehavior] ✓ Tour styles injected (deferred)');
      }
    }, 100);
  }
  
  // Set up auto-fill for drop-off field (with retry logic)
  if (window.CFG.prefillDropoff) {
    setupDropoffAutoFill();
  }
  
  // Additional safety: check for form in DOM and re-apply styles if needed
  setTimeout(() => {
    const form = document.querySelector('#_builder-form');
    if (form && window.CFG.hideDropoff) {
      // Force hide any drop-off fields that might have appeared late
      const dropoffFields = document.querySelectorAll('[data-name="dropoff_location"], [name="dropoff_location"]');
      dropoffFields.forEach(field => {
        if (field.style.display !== 'none') {
          field.style.display = 'none !important';
          console.log('[TourBehavior] ✓ Force-hidden late-appearing drop-off field');
        }
      });
    }
  }, 500);
}

// Auto-fill drop-off field with page title
function setupDropoffAutoFill() {
  console.log('[AutoFill] Setting up drop-off auto-fill...');
  
  function fillDropoffField() {
    // Get page title, clean it up
    const pageTitle = document.title
      .replace(/\s*[\|\-\–\—]\s*.*$/, '') // Remove everything after |, -, –, or —
      .trim();
    
    if (!pageTitle) {
      console.log('[AutoFill] No page title found');
      return;
    }
    
    // Find drop-off field with multiple selectors
    const dropoffSelectors = [
      '[data-name="dropoff_location"]',
      '[name="dropoff_location"]',
      'input[placeholder*="drop" i]',
      'input[placeholder*="destination" i]'
    ];
    
    let dropoffField = null;
    for (const selector of dropoffSelectors) {
      dropoffField = document.querySelector(selector);
      if (dropoffField) break;
    }
    
    if (dropoffField && !dropoffField.value) {
      dropoffField.value = pageTitle;
      
      // Trigger various events to ensure the value is registered
      ['input', 'change', 'blur'].forEach(eventType => {
        dropoffField.dispatchEvent(new Event(eventType, { bubbles: true }));
      });
      
      console.log(`[AutoFill] ✓ Drop-off field filled with: "${pageTitle}"`);
    } else if (!dropoffField) {
      console.log('[AutoFill] Drop-off field not found');
    } else {
      console.log('[AutoFill] Drop-off field already has value');
    }
  }
  
  // Try to fill immediately
  fillDropoffField();
  
  // Also try after form is fully loaded
  setTimeout(fillDropoffField, 500);
  setTimeout(fillDropoffField, 1000);
  
  // Listen for form changes in case field appears later
  const observer = new MutationObserver(() => {
    fillDropoffField();
  });
  
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  
  // Stop observing after 10 seconds
  setTimeout(() => observer.disconnect(), 10000);
}

// Initialize configuration and then start form enhancement
async function initializeBookingFormWithConfig() {
  try {
    // Load configuration first
    await loadClientConfiguration();
    
    // Detect tour page context and apply appropriate settings
    detectTourPageContext();
    
    console.log(`[BookingForm] Configuration loaded from: ${window.CFG.loadedFrom}`);
    console.log(`[BookingForm] GMAPS_KEY: ${window.CFG.GMAPS_KEY?.substring(0, 10)}...`);
    
    // Re-initialize BookingForm.CONFIG with the loaded configuration
    if (window.BookingForm.initializeConfig) {
      window.BookingForm.initializeConfig();
      console.log(`[BookingForm] BookingForm.CONFIG.googleApiKey: ${window.BookingForm.CONFIG.googleApiKey?.substring(0, 10)}...`);
    } else {
      // Fallback: directly update CONFIG if initializeConfig not available yet
      if (window.BookingForm.CONFIG) {
        window.BookingForm.CONFIG.googleApiKey = window.CFG.GMAPS_KEY;
        window.BookingForm.CONFIG.countries = window.CFG.COUNTRIES;
        
        if (window.CFG.PLACES) {
          window.BookingForm.CONFIG.places = {
            ...window.BookingForm.CONFIG.places,
            fields: window.CFG.PLACES.FIELDS || window.BookingForm.CONFIG.places.fields,
            types: window.CFG.PLACES.TYPES || window.BookingForm.CONFIG.places.types,
            priorityKeywords: window.CFG.PLACES.PRIORITY_KEYWORDS || window.BookingForm.CONFIG.places.priorityKeywords
          };
        }
        console.log(`[BookingForm] Directly updated CONFIG.googleApiKey: ${window.BookingForm.CONFIG.googleApiKey?.substring(0, 10)}...`);
      }
    }
    
    // Signal that configuration is ready
    window.BookingForm.configReady = true;
    
    // Apply tour-specific behavior if detected
    if (window.CFG?.tourPageDetected) {
      applyTourPageBehavior();
    }
    
    // Re-initialize BookingForm.CONFIG with the loaded configuration
    if (window.BookingForm.initializeConfig) {
      window.BookingForm.initializeConfig();
      console.log(`[BookingForm] Re-initialized CONFIG with API key: ${window.BookingForm.CONFIG.googleApiKey?.substring(0, 10)}...`);
    }
    
    // Execute any pending initialization callbacks
    if (window.BookingForm.onConfigReady) {
      window.BookingForm.onConfigReady.forEach(callback => callback());
      window.BookingForm.onConfigReady = [];
    }
    
    // Trigger form enhancement
    if (window.BookingForm.enhance) {
      window.BookingForm.enhance();
    }
    
  } catch (error) {
    console.error('[BookingForm] Configuration loading failed:', error);
    
    // Even if config fails, try to initialize with defaults
    window.BookingForm.configReady = true;
    if (window.BookingForm.enhance) {
      window.BookingForm.enhance();
    }
  }
}

// Export the initializer
window.BookingForm.initializeWithConfig = initializeBookingFormWithConfig;
window.BookingForm.loadClientConfiguration = loadClientConfiguration;

// Auto-initialize when DOM is ready (but wait for config)
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeBookingFormWithConfig);
} else {
  // DOM already loaded, initialize immediately
  initializeBookingFormWithConfig();
}// Global configuration for the booking form
window.BookingForm = window.BookingForm || {};

// Function to initialize/update configuration
function initializeConfig() {
  window.BookingForm.CONFIG = {
    googleApiKey:
      (window.CFG && (window.CFG.GMAPS_KEY || window.CFG.PLACES_API_KEY)) || '',
    countries: (() => {
      const c = window.CFG?.COUNTRIES ?? window.CFG?.COUNTRY ?? null;
      if (!c) return null;
      const arr = Array.isArray(c) ? c : [c];
      return arr.map(x => String(x).toUpperCase());
    })(),
    places: {
      fields: window.CFG?.PLACES?.FIELDS || ['place_id','formatted_address','geometry','name','types'],
      types:  window.CFG?.PLACES?.TYPES ?? null,
      boundsRect: (() => {
        const b = window.CFG?.PLACES?.BOUNDS;
        if (!b?.sw || !b?.ne) return null;
        return { sw: b.sw, ne: b.ne };
      })(),
      biasCircle: window.CFG?.PLACES?.BIAS_CENTER || null,
      airportCodes: window.CFG?.PLACES?.AIRPORT_CODES || {},
      priorityKeywords: window.CFG?.PLACES?.PRIORITY_KEYWORDS || null,
      filter: {
        minKeep: 3,
        addressMustHaveNumber: true,
        /** Extra keywords to allow (beyond airports/hotels). */
        allowKeywords: (window.CFG?.PLACES?.FILTER?.ALLOW_KEYWORDS || [])
          .map(s => String(s).toLowerCase())
      }
    },
    geolocationTimeoutMs: 8000,   // kept for parity (we don't call geolocation)
    mapsLoadTimeoutMs: 10000,
    time: { start: '00:00', end: '23:59', stepMinutes: 15, format12: true }
  };
}

// Initialize config immediately (might have empty API key initially)
initializeConfig();

// Export function for re-initialization after config loads
window.BookingForm.initializeConfig = initializeConfig;

// --- Autocomplete type from config (default: establishments) ---
window.BookingForm.ALLOWED_TYPES = ['geocode','address','establishment','(regions)','(cities)'];
window.BookingForm.getAutocompleteTypesFromConfig = function() {
  const raw = window.CFG?.PLACES?.TYPES;

  // If explicitly null/[] -> no type restriction
  if (raw === null || (Array.isArray(raw) && raw.length === 0)) return undefined;

  // Default when unset
  if (raw === undefined) return ['establishment'];

  const arr = Array.isArray(raw) ? raw : [raw];
  const filtered = arr.filter(t => window.BookingForm.ALLOWED_TYPES.includes(t));
  if (filtered.length === 0) return ['establishment'];

  if (filtered.includes('establishment')) return ['establishment'];
  return [filtered[0]];
};// All style injectors (idempotent)

// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

function inject(id, css) {
  if (document.getElementById(id)) return;
  const s = document.createElement('style'); s.id = id; s.textContent = css;
  document.head.appendChild(s);
}

window.BookingForm.injectBaselineStyles = function() {
  inject('booking-form-minimal-styles', `
/* Page-level safety styling */
html, body { max-width: 100%; overflow-x: hidden; }
* { box-sizing: border-box; }

/* Font family override for all form elements */
body, input, button, select, textarea {
    font-family: 'Poppins', sans-serif !important;
}

/* Core icon wrapper + input padding */
.icon-field-wrapper{position:relative;display:block;width:100%;}
.icon-field-wrapper .field-icon{position:absolute;left:0.55rem;top:50%;transform:translateY(-50%);display:inline-flex;align-items:center;justify-content:center;pointer-events:none;color:#777;}
.icon-field-wrapper .field-icon svg{width:20px;height:20px;stroke:#777;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;fill:none;}
.icon-field-wrapper > input[data-iconized='1'][data-q],
.icon-field-wrapper > select[data-iconized='1'][data-q]{padding-left:2.3rem !important;}

/* Baseline field styling (inputs + selects share the same metrics) */
input[data-q], select[data-q]{
  display:inline-block !important;
  width:100% !important;
  min-width:200px !important;
  padding:10px 18px 10px 2.25rem !important; /* leaves room for the icon */
  border:2px solid #DDDDDDFF !important;
  box-shadow: 1px 1px 9px 0px #DCDCDCFF !important;
  background:#fff !important;
  line-height:1.4 !important;
  box-sizing:border-box !important;
  min-height:56px !important;
  height:auto !important;
  color:#222 !important;
}

/* Unified text color across all data-q inputs/selects */
input[data-q], select[data-q], .icon-field-wrapper input, .icon-field-wrapper select{color:#222 !important;}

/* Google Places Autocomplete (PAC) enhanced sizing & appearance (matches temp.js) */
.pac-container{
  font-family: 'Poppins', sans-serif;
  font-size: 1.05rem !important; 
  line-height: 1.35 !important;
  border: 2px solid #ddd;
  border-radius: 10px;
  box-shadow: 0 6px 18px rgba(0,0,0,.15);
  overflow: hidden;
  z-index: 4000;
}
.pac-container:empty { display: none; }
.pac-item{
  padding: 10px 14px !important; 
  font-size: 0.92rem !important;
  line-height: 1.25;
  cursor: pointer;
  border-top: 1px solid #efefef;
  background: #fff;
  color: #222;
}
.pac-item:first-child { border-top: none; }
/* Primary (top) line - this is the larger text you're looking for */
.pac-item .pac-item-query {
  display: block;
  font-size: 1.18rem !important;
  font-weight: 600;
  line-height: 1.1;
  margin: 0 0 2px 0;
  color: #222;
}
/* Secondary address fragments */
.pac-item .pac-item-query ~ span {
  display: inline;
  font-size: 0.85rem !important;
  font-weight: 400;
  color: #555;
}
.pac-item:hover, .pac-item.pac-item-selected{background:#266BBC !important; color:#fff !important;}
.pac-item:hover .pac-item-query, .pac-item.pac-item-selected .pac-item-query{color:#fff !important;}
.pac-item:hover .pac-item-query ~ span, .pac-item.pac-item-selected .pac-item-query ~ span{color:#fff !important;}
/* Mobile adjustments */
@media (max-width: 600px) {
  .pac-container { font-size: 1.12rem !important; }
  .pac-item { padding: 12px 16px !important; }
  .pac-item .pac-item-query { font-size: 1.2rem !important; }
  .pac-item .pac-item-query ~ span { font-size: 0.88rem !important; }
  
  form#_builder-form {
    padding: 0px 10px !important;
    border-top-left-radius: 10px !important;
    border-top-right-radius: 10px !important;
  }
}

/* Form wrapper margin */
#lc-form-mount .ghl-form-wrap {
  margin-bottom: 0 !important;
}

/* PAC Hide Class for temporarily hiding autocomplete */
.pac-hide .pac-container { display: none !important; }

/* PAC icon and branding styling */
.pac-icon {
    width: 18px;
    height: 18px;
    margin-right: 8px;
}
.pac-container .pac-logo:after {
  display: none;
}

/* Gradient background utility */
.gradientbg {
    background: linear-gradient(to bottom, #ffffff 0%, #F6F5F8 100%);
}

/* Date picker popover */
#pickup-date-popover{position:absolute;z-index:2147483646;background:#fff;border:1px solid #444;border-radius:8px;box-shadow:0 6px 22px rgba(0,0,0,.18);padding:10px 12px;width:320px !important;display:none;font:20px/1.3 system-ui,Arial,sans-serif !important;}
#pickup-date-popover .dp-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px !important;font-weight:600;}
#pickup-date-popover button.dp-nav{all:unset;cursor:pointer;font-size:20px !important;line-height:1;padding:4px 8px;border-radius:6px;color:#222;}
#pickup-date-popover button.dp-nav:hover{background:#f2f2f2;}
#pickup-date-popover .dp-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:4px;}
#pickup-date-popover .dp-weekdays{display:grid;grid-template-columns:repeat(7,1fr);gap:4px;font-size:12px !important;text-transform:uppercase;letter-spacing:.5px;margin-bottom:4px;color:#666;text-align:center;}
#pickup-date-popover .dp-day{width:100%;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;font-size:18px !important;cursor:pointer;border-radius:6px;user-select:none;}
#pickup-date-popover .dp-day:hover{background:#eee;}
#pickup-date-popover .dp-day.dp-disabled{opacity:.35;cursor:not-allowed;}
#pickup-date-popover .dp-day.dp-today{outline:2px solid #188BF6;outline-offset:2px;}
#pickup-date-popover .dp-day.dp-selected{background:#188BF6;color:#FFF;font-weight:600;}

/* Time picker popover */
#pickup-time-popover{position:absolute;z-index:2147483647;background:#fff;border:1px solid #444;border-radius:8px;box-shadow:0 6px 22px rgba(0,0,0,.18);padding:10px;display:none;min-width:230px;font:14px/1.2 system-ui,Arial,sans-serif;}

/* Date and Time side-by-side layout for desktop (matches temp.js behavior) */
@media (min-width:640px){
  /* Ensure the parent can place items side-by-side */
  .ghl-question .fields-container.row{
    display:flex !important;
    flex-wrap:wrap !important;
    gap: 0px 4px; /* adjust or remove if tight on space */
    align-items:flex-start;
  }

  /* Default: all wrappers full width (stacked) */
  .ghl-question .fields-container.row > .form-field-wrapper{
    width:100%;
    max-width:100%;
    flex: 0 0 100%;
    box-sizing:border-box;
  }

  /* Make just Pickup Date + Pickup Time half width */
  .ghl-question .fields-container.row > .form-field-wrapper:has([data-q="pickup_date"]),
  .ghl-question .fields-container.row > .form-field-wrapper:has([data-q="pickup_time"]){
    width: calc(50% - 2px) !important;      /* override .col-12 */
    max-width: calc(50% - 2px) !important;  /* override .col-12 */
    flex: 0 0 calc(50% - 2px) !important;   /* override .col-12 */
  }
}
  `);
  inject('booking-form-iconrow-styles', `
  .icon-field-wrapper .icon-input-row{position:relative;}
  .icon-field-wrapper .icon-input-row > input[data-iconized='1'][data-q], .icon-field-wrapper .icon-input-row > select[data-iconized='1'][data-q]{padding-left:2.3rem !important;}
  `);
};

window.BookingForm.injectValidationStyles = function() {
  inject('booking-form-validation-styles', `
/* High-specificity error states for ALL input fields to ensure consistency */
.icon-field-wrapper .icon-input-row > input[data-q].input-error,
.icon-field-wrapper .icon-input-row > input[data-q][aria-invalid='true'],
.icon-field-wrapper .icon-input-row > select[data-q].input-error,
.icon-field-wrapper .icon-input-row > select[data-q][aria-invalid='true'],
input[data-q].input-error,
input[data-q][aria-invalid='true'],
select[data-q].input-error,
select[data-q][aria-invalid='true'] {
  background: #fff !important;
  border: 2px solid #e53935 !important;
  box-shadow: 0 0 0 2px rgba(229,57,53,0.15) !important;
  outline: none !important;
  border-radius: 4px !important;
  min-height: 56px !important;
  height: auto !important;
}

/* Ultra-nuclear option - Override even the #_builder-form selectors from the screenshot */
html body #_builder-form input.form-control.input-error[data-q],
html body #_builder-form input.form-control[data-q][aria-invalid='true'],
html body #_builder-form input[data-q].input-error,
html body #_builder-form input[data-q][aria-invalid='true'],
html body #_builder-form .hl-app input.form-control.input-error[data-q],
html body #_builder-form .hl-app input.form-control[data-q][aria-invalid='true'],
html body .hl-app #_builder-form input.form-control.input-error[data-q],
html body .hl-app #_builder-form input.form-control[data-q][aria-invalid='true'],
body #_builder-form input.form-control.input-error[data-q='phone'],
body #_builder-form input.form-control[data-q='phone'][aria-invalid='true'],
body #_builder-form input.form-control.input-error[data-q='email'], 
body #_builder-form input.form-control[data-q='email'][aria-invalid='true'],
body #_builder-form input.form-control.input-error[data-q='full_name'],
body #_builder-form input.form-control[data-q='full_name'][aria-invalid='true'],
body .hl-app input.form-control.input-error[data-q='phone'],
body .hl-app input.form-control[data-q='phone'][aria-invalid='true'],
body .hl-app input.form-control.input-error[data-q='email'], 
body .hl-app input.form-control[data-q='email'][aria-invalid='true'],
body .hl-app input.form-control.input-error[data-q='full_name'],
body .hl-app input.form-control[data-q='full_name'][aria-invalid='true'],
html body input.form-control.input-error[data-q='phone'],
html body input.form-control[data-q='phone'][aria-invalid='true'],
html body input.form-control.input-error[data-q='email'], 
html body input.form-control[data-q='email'][aria-invalid='true'],
html body input.form-control.input-error[data-q='full_name'],
html body input.form-control[data-q='full_name'][aria-invalid='true'] {
  background: #fff !important;
  border: 2px solid #e53935 !important;
  border-width: 2px !important;
  border-style: solid !important;
  border-color: #e53935 !important;
  border-radius: 4px !important;
  box-shadow: 0 0 0 2px rgba(229,57,53,0.15) !important;
  outline: none !important;
  min-height: 56px !important;
  height: auto !important;
  font-family: 'Poppins', sans-serif !important;
  color: #222 !important;
}

/* Hide GoHighLevel's default error messages to prevent conflicts */
.form-builder--item .error {
  display: none !important;
}

/* Disable placeholder creep-up behavior for all fields - SIMPLE VERSION */
input[data-q]::placeholder {
  font-size: 20px !important;
  transform: none !important;
  transition: none !important;
}

input[data-q]:focus::placeholder,
input[data-q].input-error::placeholder,
input[data-q][aria-invalid='true']::placeholder {
  font-size: 20px !important;
  transform: none !important;
  transition: none !important;
}

/* Wrapper may shake but shouldn't show red border */
.icon-field-wrapper.input-error{border-radius:6px;}
.field-error{display:block;margin-top:1px;color:#e53935;font-size:12px;line-height:1.2;border:0 !important;box-shadow:none !important;}
@keyframes bf-shake{10%,90%{transform:translateX(-1px);}20%,80%{transform:translateX(2px);}30%,50%,70%{transform:translateX(-4px);}40%,60%{transform:translateX(4px);}}
.shake{animation:bf-shake 400ms ease-in-out;}

/* Equalize border radius for step-1 inputs (normal + error states) */
.icon-field-wrapper .icon-input-row > input[data-q='pickup_location'],
.icon-field-wrapper .icon-input-row > input[data-q='drop-off_location'],
.icon-field-wrapper .icon-input-row > input[data-q='pickup_date'],
.icon-field-wrapper .icon-input-row > input[data-q='pickup_time'],
.icon-field-wrapper .icon-input-row > input[data-q='number_of_passengers'],
input[data-q='pickup_location'],
input[data-q='drop-off_location'],
input[data-q='pickup_date'],
input[data-q='pickup_time'],
input[data-q='number_of_passengers'],
input[data-q='pickup_location'][aria-invalid='true'],
input[data-q='drop-off_location'][aria-invalid='true'],
input[data-q='pickup_date'][aria-invalid='true'],
input[data-q='pickup_time'][aria-invalid='true'],
input[data-q='number_of_passengers'][aria-invalid='true'],
input[data-q='pickup_location'].input-error,
input[data-q='drop-off_location'].input-error,
input[data-q='pickup_date'].input-error,
input[data-q='pickup_time'].input-error,
input[data-q='number_of_passengers'].input-error {
  border-radius: 4px !important;
}

/* Number of passengers placeholder color (matches temp.js) */
select[data-q='number_of_passengers'].is-placeholder {
  color: #8C8C8C !important;
}

/* Form control padding override (matches temp.js) */
.hl-app .form-control {
  padding: 10px 20px !important;
}

/* Number of passengers styling: consistent with other fields */
.icon-field-wrapper .icon-input-row > select[data-q='number_of_passengers'],
select[data-q='number_of_passengers'] {
  background: #fff !important;
  border: 2px solid #DDDDDDFF !important;
  box-shadow: 1px 1px 9px 0px #DCDCDCFF !important;
  outline: none !important;
}

/* Number of passengers hover/focus states */
.icon-field-wrapper .icon-input-row > select[data-q='number_of_passengers']:hover,
.icon-field-wrapper .icon-input-row > select[data-q='number_of_passengers']:focus,
.icon-field-wrapper .icon-input-row > select[data-q='number_of_passengers']:focus-visible,
.icon-field-wrapper .icon-input-row > select[data-q='number_of_passengers']:active,
select[data-q='number_of_passengers']:hover,
select[data-q='number_of_passengers']:focus,
select[data-q='number_of_passengers']:active {
  background: #fff !important;
  border: 2px solid #DDDDDDFF !important;
  box-shadow: 1px 1px 9px 0px #DCDCDCFF !important;
  outline: none !important;
}

/* Number of passengers error states - now handled by general error styling above */
  `);
  inject('booking-form-fade-styles', `
    .bf-fade-anim{transition:opacity 220ms ease, transform 220ms ease; will-change: opacity, transform;}
    .bf-fade-out{opacity:0 !important; transform: translateY(-4px);}
    .bf-fade-in-init{opacity:0; transform: translateY(6px);}
  `);
};

window.BookingForm.injectCtaStyles = function() {
  inject('booking-form-next-mobile-styles', `
    .ghl-btn.ghl-footer-next.bf-next{display:inline-flex;align-items:center;gap:8px;font-size:20px}
    .ghl-btn.ghl-footer-next .bf-next-label{display:none !important;font-weight:500}
    @media (max-width:768px){
      .ghl-btn.ghl-footer-next.bf-next{width:auto !important;padding-inline:14px !important}
      .ghl-btn.ghl-footer-next .bf-next-label{display:inline-block !important}
    }
  `);
  inject('booking-form-cta-styles', `
    .ghl-btn.ghl-submit-btn.bf-cta{display:inline-flex;gap:10px;white-space:nowrap}
    .ghl-btn.ghl-submit-btn.bf-cta .bf-arrow{width:18px;height:18px;transition:transform .22s ease}
    .ghl-btn.ghl-submit-btn.bf-cta .bf-arrow svg{stroke:white !important;fill:none !important}
    .ghl-btn.ghl-submit-btn.bf-cta:hover .bf-arrow{transform:translateX(5px)}
    .ghl-btn.ghl-submit-btn.bf-cta .bf-cta-text{font-size:20px !important}
    
    /* Loading state styling */
    .ghl-btn.ghl-submit-btn.bf-cta.bf-loading {
      opacity: 0.8;
      cursor: not-allowed;
      pointer-events: none;
    }
    .ghl-btn.ghl-submit-btn.bf-cta.bf-loading:hover .bf-arrow {
      transform: none;
    }
    .bf-spinner {
      animation: bf-spin 1s linear infinite !important;
      color: white !important;
    }
    @keyframes bf-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Fullscreen loading overlay styles */
    .bf-loading-overlay {
      transition: opacity 0.3s ease-in-out !important;
    }
    .bf-loading-overlay .bf-loading-content {
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
      justify-content: center !important;
      gap: 20px !important;
      text-align: center !important;
    }
    .bf-loading-overlay .bf-loading-spinner-container {
      width: 60px !important;
      height: 60px !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }
    .bf-loading-overlay .bf-spinner {
      width: 50px !important;
      height: 50px !important;
      animation: bf-spin 1s linear infinite !important;
    }
    .bf-loading-overlay .bf-loading-text {
      font-family: "Poppins", sans-serif !important;
      font-size: 53px !important;
      font-weight: 700 !important;
      letter-spacing: -1px !important;
      color: white !important;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3) !important;
    }
    
    @media (max-width: 768px) {
      .bf-loading-overlay .bf-loading-text {
        font-size: 34px !important;
      }
    }
    
    /* Survey step transitions */
    .slide-no-1, .slide-no-2, [class*="slide-no-"] {
      transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
    }
    .survey-step-fade-out {
      opacity: 0;
      transform: translateX(-20px);
    }
    .survey-step-fade-in {
      opacity: 1;
      transform: translateX(0);
    }
  `);
  inject('booking-form-misc-styles', `
    /* Thank you message padding */
    #_builder-form .thank-you-message > div {
      padding: 40px 0px !important;
    }
    
    /* Social icon padding (if present) */
    .social-icon {
      padding: 0.3rem !important;
    }
  `);
};

// Tour-specific styles for hideDropoff and stickyForm
window.BookingForm.injectTourStyles = function() {
  inject('booking-form-tour-styles', `
    /* Hide drop-off field for tour pages - comprehensive selectors */
    .tour-page-hide-dropoff [data-name="dropoff_location"],
    .tour-page-hide-dropoff [name="dropoff_location"],
    .tour-page-hide-dropoff input[placeholder*="drop" i],
    .tour-page-hide-dropoff input[placeholder*="destination" i],
    body.tour-page-hide-dropoff [data-name="dropoff_location"],
    body.tour-page-hide-dropoff [name="dropoff_location"],
    body.tour-page-hide-dropoff input[placeholder*="drop" i],
    body.tour-page-hide-dropoff input[placeholder*="destination" i] {
      display: none !important;
      visibility: hidden !important;
      height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* Hide the parent row/container that might have spacing */
    .tour-page-hide-dropoff .ghl-form-row:has([data-name="dropoff_location"]),
    .tour-page-hide-dropoff .ghl-form-row:has([name="dropoff_location"]),
    .tour-page-hide-dropoff [id*="dropoff"]:not(input):not(select):not(textarea),
    body.tour-page-hide-dropoff .ghl-form-row:has([data-name="dropoff_location"]),
    body.tour-page-hide-dropoff .ghl-form-row:has([name="dropoff_location"]),
    body.tour-page-hide-dropoff [id*="dropoff"]:not(input):not(select):not(textarea) {
      display: none !important;
      visibility: hidden !important;
      height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* Hide specific div ID that contains drop-off field */
    .tour-page-hide-dropoff #el_pmkaWAYqmvey4VusfPvF_Ff2mstR1InquK2d7G2hX_2,
    body.tour-page-hide-dropoff #el_pmkaWAYqmvey4VusfPvF_Ff2mstR1InquK2d7G2hX_2 {
      display: none !important;
      visibility: hidden !important;
      height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* Remove padding from survey form */
    .survey-2xXWpyyoCV .hl_form-builder--main {
      padding: 0px !important;
    }
    
    /* Sticky form positioning for tour pages - multiple selectors */
    .tour-page-sticky-form #_builder-form,
    body.tour-page-sticky-form #_builder-form,
    .tour-page-sticky-form .hl_form-builder,
    body.tour-page-sticky-form .hl_form-builder,
    .tour-page-sticky-form .survey-2xXWpyyoCV,
    body.tour-page-sticky-form .survey-2xXWpyyoCV {
      position: sticky !important;
      top: 20px !important;
      z-index: 1000 !important;
      background: white !important;
      border-radius: 8px !important;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06) !important;
      padding: 10px !important;
      max-height: calc(100vh - 40px) !important;
      overflow-y: auto !important;
      margin-bottom: 20px !important;
    }
    
    /* Ensure sticky works on the actual form container with no padding */
    .tour-page-sticky-form .hl_form-builder--main,
    body.tour-page-sticky-form .hl_form-builder--main {
      padding: 0px !important;
    }
    
    /* Ensure form container has proper spacing on mobile */
    @media (max-width: 768px) {
      .tour-page-sticky-form #_builder-form,
      body.tour-page-sticky-form #_builder-form,
      .tour-page-sticky-form .hl_form-builder,
      body.tour-page-sticky-form .hl_form-builder,
      .tour-page-sticky-form .survey-2xXWpyyoCV,
      body.tour-page-sticky-form .survey-2xXWpyyoCV,
      .tour-page-sticky-form .hl_form-builder--main,
      body.tour-page-sticky-form .hl_form-builder--main {
        position: relative !important;
        top: auto !important;
        margin: 20px 0 !important;
      }
    }
    
    /* Ensure passenger dropdown works with sticky form */
    .tour-page-sticky-form .passenger-dropdown,
    .tour-page-sticky-form .passenger-popup,
    body.tour-page-sticky-form .passenger-dropdown,
    body.tour-page-sticky-form .passenger-popup {
      z-index: 10000 !important;
      position: relative !important;
    }
  `);
};

// Initialize styles immediately
window.BookingForm.injectBaselineStyles();
window.BookingForm.injectValidationStyles();
window.BookingForm.injectCtaStyles();// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

window.BookingForm.PARAM_ALLOWLIST = [
  'pickup_location','dropoff_location','pickup_date','pickup_time','number_of_passengers',
  'first_name','last_name','email','phone'
];

window.BookingForm.cacheIncomingParams = function(qs){
  window.BookingForm.PARAM_ALLOWLIST.forEach(k=>{
    if (qs.has(k)) { try { sessionStorage.setItem('lead:'+k, qs.get(k)||''); } catch {} }
  });
};

window.BookingForm.getParam = function(qs, name){
  const v = qs.get(name);
  if (v && String(v).trim()) return v;
  try { return sessionStorage.getItem('lead:'+name) || ''; } catch { return ''; }
};// Section 7: Icon Injection / Visual Enhancement from temp.js

// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

// Enhanced layout for date and time fields on desktop (custom from your temp.js)
function enhanceDateTimeLayout(rootDoc) {
  if (!rootDoc) return;
  
  // Find date and time input wrappers
  const dateWrapper = rootDoc.querySelector('.icon-field-wrapper:has(input[data-q="pickup_date"])') ||
                     rootDoc.querySelector('input[data-q="pickup_date"]')?.closest('.icon-field-wrapper');
  const timeWrapper = rootDoc.querySelector('.icon-field-wrapper:has(input[data-q="pickup_time"])') ||
                     rootDoc.querySelector('input[data-q="pickup_time"]')?.closest('.icon-field-wrapper');
  
  if (!dateWrapper || !timeWrapper) return;
  
  // Check if they're siblings and not already in a flex container
  if (dateWrapper.nextElementSibling === timeWrapper && !dateWrapper.parentElement.classList.contains('bf-datetime-container')) {
    // Create flex container
    const container = document.createElement('div');
    container.className = 'bf-datetime-container';
    container.style.cssText = 'display: flex; gap: 12px; align-items: flex-start;';
    
    // Insert container before date wrapper
    dateWrapper.parentElement.insertBefore(container, dateWrapper);
    
    // Move both wrappers into container and set flex properties
    dateWrapper.style.cssText = 'flex: 2; min-width: 0;'; // Date gets more space
    timeWrapper.style.cssText = 'flex: 1; min-width: 0;'; // Time gets less space
    
    container.appendChild(dateWrapper);
    container.appendChild(timeWrapper);
  }
}

// Section 7 implementation from temp.js
function enhanceVisual(rootDoc){
  if(!rootDoc) return;
  const ICONS={
    'pickup_location':`<svg viewBox='0 0 24 24' aria-hidden='true'><path d="M21 10c0 7-9 13-9 13S3 17 3 10a9 9 0 1 1 18 0Z"/><circle cx="12" cy="10" r="3"/></svg>`,
    'drop-off_location':`<svg viewBox='0 0 24 24' aria-hidden='true'><path d="M21 10c0 7-9 13-9 13S3 17 3 10a9 9 0 1 1 18 0Z"/><circle cx="12" cy="10" r="3"/></svg>`,
    'pickup_date':`<svg viewBox='0 0 24 24' aria-hidden='true'><rect x='3' y='5' width='18' height='16' rx='2' ry='2'/><line x1='16' y1='3' x2='16' y2='7'/><line x1='8' y1='3' x2='8' y2='7'/><line x1='3' y1='11' x2='21' y2='11'/></svg>`,
    'pickup_time':`<svg viewBox='0 0 24 24' aria-hidden='true'><circle cx='12' cy='12' r='10'/><polyline points='12 6 12 12 16 14'/></svg>`,
    'number_of_passengers':`<svg viewBox='0 0 24 24' aria-hidden='true'><path d='M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2'/><circle cx='9' cy='7' r='4'/><path d='M22 21v-2a4 4 0 0 0-3-3.87'/><path d='M16 3.13a4 4 0 0 1 0 7.75'/></svg>`,
    'full_name':`<svg viewBox='0 0 24 24' aria-hidden='true'><path d='M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2'/><circle cx='9' cy='7' r='4'/></svg>`,
    'email':`<svg viewBox='0 0 24 24' aria-hidden='true'><path d='M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2Z'/><polyline points='22,6 12,13 2,6'/></svg>`,
    'phone':`<svg viewBox='0 0 24 24' aria-hidden='true'><path d='M22 16.92v3a2 2 0 0 1-2.18 2 19.86 19.86 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.86 19.86 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.66 12.66 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.66 12.66 0 0 0 2.81.7A2 2 0 0 1 22 16.92Z'/></svg>`
  };
  function wrap(el, svg, key){
    if(!el) return;
    // Find or create wrapper
    let wrapDiv = el.closest('.icon-field-wrapper');
    if(!wrapDiv){
      wrapDiv=document.createElement('div');
      wrapDiv.className='icon-field-wrapper';
      el.parentNode.insertBefore(wrapDiv, el);
    }
    // Ensure an input-row exists (icon aligns to this row only)
    let row = wrapDiv.querySelector(':scope > .icon-input-row');
    if(!row){
      row=document.createElement('div');
      row.className='icon-input-row';
      // place at top so any error message can appear below
      wrapDiv.insertBefore(row, wrapDiv.firstChild);
    }
    // Move input into the row if not already
    if(el.parentElement !== row){
      row.appendChild(el);
    }
    // Create or move the icon into the row
    let span = row.querySelector(':scope > .field-icon') || wrapDiv.querySelector(':scope > .field-icon');
    if(!span){
      span=document.createElement('span');
      span.className='field-icon';
      span.setAttribute('aria-hidden','true');
      if(key) span.setAttribute('data-for', key);
      span.innerHTML=svg;
    } else {
      // Ensure attributes match latest key
      if(key) span.setAttribute('data-for', key);
    }
    if(span.parentElement !== row){
      row.appendChild(span);
    }
    el.dataset.iconized='1';
  }
  Object.entries(ICONS).forEach(([k,svg])=>{
    [...rootDoc.querySelectorAll(`input[data-q='${k}'],select[data-q='${k}']`)].forEach(el=>wrap(el,svg,k));
    [...rootDoc.querySelectorAll(`input[name='${k}'],select[name='${k}']`)].forEach(el=>wrap(el,svg,k));
  });
}

// Enhance Step 1 NEXT button on mobile by appending a "NEXT" label next to the arrow
function enhanceNextButtonMobile(rootDoc){
  if(!rootDoc) rootDoc = document;
  const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
  const btns = rootDoc.querySelectorAll('.ghl-btn.ghl-footer-next');
  btns.forEach(btn => {
    let labelSpan = btn.querySelector('.bf-next-label');
    if(isMobile){
      // Ensure alignment class exists only on mobile
      btn.classList.add('bf-next');
      // Add or move label to the first position
      if(!labelSpan){
        labelSpan = document.createElement('span');
        labelSpan.className = 'bf-next-label';
        labelSpan.textContent = 'NEXT';
        btn.insertBefore(labelSpan, btn.firstChild);
      } else if (btn.firstElementChild !== labelSpan) {
        btn.insertBefore(labelSpan, btn.firstChild);
      }
    } else {
      // Desktop: remove our alignment class and custom label to avoid side effects
      btn.classList.remove('bf-next');
      if(labelSpan) labelSpan.remove();
    }
  });
}

// Toggle NEXT label on viewport changes
try {
  const mq = window.matchMedia('(max-width: 768px)');
  const reapply = ()=> enhanceNextButtonMobile(document);
  if(mq.addEventListener){ mq.addEventListener('change', reapply); }
  else if(mq.addListener){ mq.addListener(reapply); }
  window.addEventListener('resize', reapply, { passive: true });
} catch(_) {}

// Initialize survey step transitions (disabled to prevent navigation issues)
// Remove the disabled approach since it causes navigation issues
// (Survey transitions are handled by GoHighLevel's platform)
function initSurveyTransitions() {
  // Intentionally disabled to prevent navigation issues
}

// Enhance the Step 2 submit button with CTA text + white arrow + loading state
function enhanceSubmitButton(rootDoc){
  if(!rootDoc) rootDoc = document;
  const btns = rootDoc.querySelectorAll('.ghl-btn.ghl-submit-btn');
  btns.forEach(btn => {
    if(btn.dataset.bfCtaWired === '1') return;
    // Replace text with our CTA while preserving the button element and its listeners
    const label = 'GET YOUR QUOTE!';
    btn.classList.add('bf-cta');
    btn.innerHTML = `<span class="bf-cta-text">${label}</span>`+
      `<span class="bf-arrow" aria-hidden="true">`+
      `<svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">`+
      `<line x1="5" y1="12" x2="19" y2="12" stroke="white" stroke-width="2" stroke-linecap="round"></line>`+
      `<line x1="12" y1="5" x2="19" y2="12" stroke="white" stroke-width="2" stroke-linecap="round"></line>`+
      `<line x1="12" y1="19" x2="19" y2="12" stroke="white" stroke-width="2" stroke-linecap="round"></line>`+
      `</svg>`+
      `</span>`;
    
    // Add loading state functionality with fullscreen overlay approach
    btn.addEventListener('click', function(e) {
      // Check if overlay already exists
      if (document.querySelector('.bf-loading-overlay')) {
        return; // Loading overlay already exists
      }
      
      // Create fullscreen loading overlay immediately
      const loadingOverlay = document.createElement('div');
      loadingOverlay.className = 'bf-loading-overlay';
      loadingOverlay.innerHTML = `
        <div class="bf-loading-content">
          <div class="bf-loading-spinner-container">
            <svg class="bf-spinner" viewBox="0 0 24 24" focusable="false" aria-hidden="true">
              <circle cx="12" cy="12" r="10" fill="none" stroke="white" stroke-width="2" opacity="0.25"/>
              <path fill="white" d="M4,12a8,8 0 0,1 16,0" opacity="0.75"/>
            </svg>
          </div>
          <span class="bf-loading-text">Processing Your Request...</span>
        </div>
      `;
      
      // Make it fullscreen with subtle styling
      loadingOverlay.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        background: rgba(0, 0, 0, 0.7) !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        z-index: 999999 !important;
        backdrop-filter: blur(5px) !important;
        font-family: "Poppins", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important;
      `;
      
      document.body.appendChild(loadingOverlay);
      
      // Check for validation errors after a brief delay
      setTimeout(() => {
        const hasErrors = rootDoc.querySelectorAll('.error, .ghl-error, [data-error="true"], .invalid').length > 0;
        const formElement = btn.closest('form');
        const isFormValid = formElement ? formElement.checkValidity() : true;
        
        if (hasErrors || !isFormValid) {
          // Remove loading overlay if validation fails
          loadingOverlay.remove();
        } else {
          // Keep overlay visible during submission and redirect
        }
      }, 100);
      
    });
    
    btn.dataset.bfCtaWired = '1';
  });
}

// Expose functions on global namespace
window.BookingForm.enhanceVisual = enhanceVisual;
window.BookingForm.enhanceDateTimeLayout = enhanceDateTimeLayout;
window.BookingForm.enhanceNextButtonMobile = enhanceNextButtonMobile;
window.BookingForm.enhanceSubmitButton = enhanceSubmitButton;
window.BookingForm.initSurveyTransitions = initSurveyTransitions;// Prevent past dates + normalize display format

// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

window.BookingForm.attachPickupDateGuard = function(rootDoc){
  const input = rootDoc.querySelector('input[data-q="pickup_date"]');
  if (!input || input.dataset.dateGuard === '1') return;
  input.dataset.dateGuard = '1';
  
  // Minimal styling - main layout handled by CSS to prevent shifts
  try {
    input.style.setProperty('color', '#000', 'important');
    input.style.setProperty('background', '#fff', 'important');
    input.style.setProperty('opacity', '1', 'important');
    // Width and padding are now handled by CSS to prevent layout shift
  } catch(_) {}
  
  const todayStart = () => { const d=new Date(); d.setHours(0,0,0,0); return d; };
  const MONTHS = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const WEEKDAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
  function parseLocalDate(str){
    if (!str) return null;
    let s = str.trim();
    // Remove commas & ordinal suffixes (1st/2nd/3rd/4th...)
    s = s.replace(/,/g,'').replace(/\b(\d{1,2})(st|nd|rd|th)\b/i,'$1');
    // Remove leading weekday (full or 3‑letter) if present
    s = s.replace(/^(Sun(day)?|Mon(day)?|Tue(sday)?|Wed(nesday)?|Thu(rsday)?|Fri(day)?|Sat(urday)?)\s+/i,'');
    // YYYY-MM-DD
    let m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/); if (m) return new Date(+m[1],+m[2]-1,+m[3]);
    // MM/DD/YYYY or M-D-YYYY
    m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
    if (m){ const a=+m[1], b=+m[2], y=+m[3]; const day=a>12?a:b, mon=a>12?b:a; return new Date(y,mon-1,day);} 
    // Full MonthName Day Year
    m = s.match(/^(January|February|March|April|May|June|July|August|September|October|November|December) (\d{1,2}) (\d{4})$/i);
    if (m){ return new Date(+m[3], MONTHS.findIndex(M=>M.toLowerCase()===m[1].toLowerCase()), +m[2]); }
    // Abbrev MonthName Day Year
    m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{1,2}) (\d{4})$/i);
    if (m){ const fullIndex=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'].indexOf(m[1].substr(0,3)); return new Date(+m[3], fullIndex, +m[2]); }
    const d=new Date(s); return isNaN(d)?null:new Date(d.getFullYear(),d.getMonth(),d.getDate());
  }
  function formatDisplay(d){
    const month = MONTHS[d.getMonth()].slice(0,3); // Abbrev month
    const day = d.getDate();
    const yr = d.getFullYear();
    const weekday = WEEKDAYS[d.getDay()].slice(0,3); // Abbrev weekday
    return `${weekday}, ${month} ${day}, ${yr}`;
  }
  function enforce(){
    const d=parseLocalDate(input.value);
    if(!d){ input.setCustomValidity(''); return; }
    if(d<todayStart()){ input.setCustomValidity('Please choose today or a future date.'); input.value=''; input.reportValidity?.(); }
    else {
      input.setCustomValidity('');
      // Format immediately for user-friendly display
      input.value = formatDisplay(d);
    }
  }
  input.addEventListener('blur',enforce);
  input.addEventListener('change',enforce);
  input.addEventListener('input',()=>{ if(input.value.length>=6) enforce(); });
  
  // Watch for value changes from date picker components
  let lastValue = input.value;
  const observer = new MutationObserver(() => {
    if (input.value !== lastValue) {
      lastValue = input.value;
      enforce();
    }
  });
  observer.observe(input, { attributes: true, attributeFilter: ['value'] });
  
  // Also use a periodic check to catch any missed updates (guard against duplicates)
  if (input.__bfDateGuardInt) clearInterval(input.__bfDateGuardInt);
  input.__bfDateGuardInt = setInterval(() => {
    if (input.value !== lastValue && input.value.length >= 6) {
      lastValue = input.value;
      enforce();
    }
  }, 500);
  
  // Remove the wrapper-based event handling that's causing issues
  // const wrapper=input.closest('.vdpWithInput, .vdpComponent, .date-picker-field-survey');
  // if(wrapper) wrapper.addEventListener('click',()=>{ startWatch(); setTimeout(enforce,50); });
};// Small popup calendar → writes formatted string, fires input/change

// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

(function initDatePicker(){
  if(window.__pickupDatePicker) return;
  const MONTHS=['January','February','March','April','May','June','July','August','September','October','November','December'];
  const WEEKDAYS_SHORT=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  function formatVerbose(d){ const wd=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][d.getDay()]; const mon=MONTHS[d.getMonth()].slice(0,3); return `${wd}, ${mon} ${d.getDate()}, ${d.getFullYear()}`; }
  const pop=document.createElement('div'); pop.id='pickup-date-popover'; pop.setAttribute('role','dialog'); pop.setAttribute('aria-hidden','true'); document.body.appendChild(pop);
  const state={open:false, month:new Date().getMonth(), year:new Date().getFullYear(), input:null};
  function todayStart(){ const d=new Date(); d.setHours(0,0,0,0); return d; }
  function build(){
    const first=new Date(state.year,state.month,1); const startDow=first.getDay();
    const daysInMonth=new Date(state.year,state.month+1,0).getDate();
    const prevDays=new Date(state.year,state.month,0).getDate();
    let html=`<div class="dp-header"><button type="button" class="dp-nav" data-nav="-1" aria-label="Previous Month">‹</button><div>${MONTHS[state.month]} ${state.year}</div><button type="button" class="dp-nav" data-nav="1" aria-label="Next Month">›</button></div>`;
    html+=`<div class="dp-weekdays">${WEEKDAYS_SHORT.map(w=>`<div>${w}</div>`).join('')}</div>`;
    html+='<div class="dp-grid">';
    // leading blanks from previous month (disabled)
    for(let i=0;i<startDow;i++){ const d=prevDays-startDow+i+1; html+=`<div class="dp-day dp-disabled" aria-hidden="true">${d}</div>`; }
    const today=todayStart();
    for(let day=1; day<=daysInMonth; day++){
      const current=new Date(state.year,state.month,day); current.setHours(0,0,0,0);
      const disabled=current<today; const isToday=current.getTime()===today.getTime();
      const classes=['dp-day']; if(disabled) classes.push('dp-disabled'); if(isToday) classes.push('dp-today');
      html+=`<div class="${classes.join(' ')}" data-day="${day}" role="button" tabindex="${disabled?-1:0}" aria-disabled="${disabled}" aria-label="${MONTHS[state.month]} ${day}, ${state.year}">${day}</div>`;
    }
    html+='</div>';
    pop.innerHTML=html;
  }
  function openFor(input){ state.input=input; const now=new Date(); state.month=now.getMonth(); state.year=now.getFullYear(); build(); position(); pop.style.display='block'; pop.setAttribute('aria-hidden','false'); state.open=true; setTimeout(()=>{ document.addEventListener('mousedown',outside,true); document.addEventListener('keydown',keyNav,true); },0); }
  function close(){ if(!state.open) return; state.open=false; pop.style.display='none'; pop.setAttribute('aria-hidden','true'); document.removeEventListener('mousedown',outside,true); document.removeEventListener('keydown',keyNav,true); }
  function position(){ if(!state.input) return; const r=state.input.getBoundingClientRect(); pop.style.top=window.scrollY + r.bottom + 6 + 'px'; pop.style.left=window.scrollX + r.left + 'px'; }
  function outside(e){ if(pop.contains(e.target) || e.target===state.input) return; close(); }
  function keyNav(e){ if(e.key==='Escape'){ close(); state.input?.focus(); } }
  pop.addEventListener('click',e=>{ const nav=e.target.getAttribute('data-nav'); if(nav){ state.month+= +nav; if(state.month<0){ state.month=11; state.year--; } else if(state.month>11){ state.month=0; state.year++; } build(); return; } const day=e.target.getAttribute('data-day'); if(day){ const sel=new Date(state.year,state.month,+day); if(sel<todayStart()) return; const formatted=formatVerbose(sel); state.input.value=formatted; state.input.setAttribute('value',formatted); state.input.dispatchEvent(new Event('input',{bubbles:true})); state.input.dispatchEvent(new Event('change',{bubbles:true})); close(); }});
  window.addEventListener('resize',()=> position()); window.addEventListener('scroll',()=> position(), true);
  function attach(rootDoc){ const input=rootDoc.querySelector('input[data-q="pickup_date"]'); if(!input || input.dataset.datePickerWired==='1') return; input.dataset.datePickerWired='1'; input.readOnly=true; input.addEventListener('focus',()=> openFor(input)); input.addEventListener('click',()=> openFor(input)); }
  window.__pickupDatePicker={ openFor, close, attach };
  // initial attach
  attach(document);
})();

// Time picker - using IIFE singleton pattern from temp.js
window.BookingForm = window.BookingForm || {};

(function initSingletonTimePicker(){
  if(window.__singletonTimePicker) return; // already initialized
  const cfgRef = () => window.BookingForm.CONFIG.time;
  const state = { open:false, input:null, h:6, m:0 };
  const root = document.createElement('div');
  root.id='pickup-time-popover';
  root.style.cssText='position:absolute;inset:auto auto auto auto;z-index:2147483647;background:#fff;border:1px solid #444;border-radius:8px;box-shadow:0 6px 22px rgba(0,0,0,.18);padding:10px;display:none;min-width:230px;font:14px/1.2 system-ui,Arial,sans-serif;';
  root.innerHTML=`<div style="display:flex;gap:18px;justify-content:center;align-items:flex-start;">
    <div data-col="hour" style="text-align:center;">
      <button type="button" data-act="hu" aria-label="Hour up" style="all:unset;cursor:pointer;font-size:16px;">▲</button>
      <div data-part="hour" style="font-size:28px;font-weight:600;margin:6px 0 6px;">06</div>
      <button type="button" data-act="hd" aria-label="Hour down" style="all:unset;cursor:pointer;font-size:16px;">▼</button>
    </div>
    <div style="font-size:28px;padding-top:22px;font-weight:700;">:</div>
    <div data-col="minute" style="text-align:center;">
      <button type="button" data-act="mu" aria-label="Minute up" style="all:unset;cursor:pointer;font-size:16px;">▲</button>
      <div data-part="minute" style="font-size:28px;font-weight:600;margin:6px 0 6px;">00</div>
      <button type="button" data-act="md" aria-label="Minute down" style="all:unset;cursor:pointer;font-size:16px;">▼</button>
    </div>
    <div data-col="ampm" style="text-align:center;" data-ampm-col>
      <button type="button" data-act="tu" aria-label="Toggle AM/PM" style="all:unset;cursor:pointer;font-size:16px;">▲</button>
      <div data-part="ampm" style="font-size:28px;font-weight:600;margin:6px 0 6px;">AM</div>
      <button type="button" data-act="td" aria-label="Toggle AM/PM" style="all:unset;cursor:pointer;font-size:16px;">▼</button>
    </div>
  </div>
  <div style="display:flex;justify-content:flex-start;margin-top:12px;">
    <button type="button" data-act="ok" style="background:#188BF6;color:#FFF;font-weight:600;border:none;padding:8px 40px;border-radius:6px;cursor:pointer;">OK</button>
    <button type="button" data-act="x" style="margin-left:8px;background:transparent;color:#666;border:none;padding:8px 10px;cursor:pointer;">Cancel</button>
  </div>`;
  document.body.appendChild(root);
  function parse(str){ if(!str) return null; const m=str.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)?$/i); if(!m) return null; let h=+m[1]; const mn=+m[2]; if(m[3]){ const ap=m[3].toUpperCase(); if(ap==='PM'&&h<12) h+=12; if(ap==='AM'&&h===12) h=0; } if(h>23||mn>59) return null; return {h,m:mn}; }
  function clamp(h,m){
    // Constrains within configured window (now full day 00:00–23:59 unless changed)
    const cfg=cfgRef(); const [sh,sm]=cfg.start.split(':').map(Number); const [eh,em]=cfg.end.split(':').map(Number);
    let mins=h*60+m; const s=sh*60+sm, e=eh*60+em; if(mins<s) mins=s; if(mins>e) mins=e; return {h:Math.floor(mins/60), m:mins%60};
  }
  function fmt(h,m){ const cfg=cfgRef(); if(cfg.format12){ const ap=h>=12?'PM':'AM'; let hh=h%12; if(hh===0) hh=12; return `${String(hh).padStart(2,'0')}:${String(m).padStart(2,'0')} ${ap}`; } return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`; }
  function quantize(m){
    const step = cfgRef().stepMinutes || 15;
    return Math.floor(m / step) * step;
  }
  function updateDisplay(){ const cfg=cfgRef(); const hourEl=root.querySelector('[data-part="hour"]'); const minEl=root.querySelector('[data-part="minute"]'); const apEl=root.querySelector('[data-part="ampm"]'); let displayH=state.h; if(cfg.format12){ let hh=displayH%12; if(hh===0) hh=12; hourEl.textContent=String(hh).padStart(2,'0'); if(apEl) apEl.textContent=state.h>=12?'PM':'AM'; } else { hourEl.textContent=String(displayH).padStart(2,'0'); if(apEl) apEl.parentElement.style.display='none'; } minEl.textContent=String(Math.floor(state.m/(cfgRef().stepMinutes||15))*(cfgRef().stepMinutes||15)).padStart(2,'0'); }
  function adjust(hd, md, toggle){
    const cfg=cfgRef();
    if(typeof hd==='number'){
      // Pure 24h arithmetic; AM/PM derives from final hour value.
      state.h = (state.h + hd + 24) % 24;
    }
    if(toggle){
      state.h = (state.h + 12) % 24; // flip period
    }
    if(typeof md==='number'){
      const step = cfg.stepMinutes || 15;
      let total = state.h*60 + state.m + step*md;
      total = ((total % (24*60)) + 24*60) % (24*60);
      state.h = Math.floor(total/60);
      state.m = total % 60;
    }
    ({h:state.h,m:state.m} = clamp(state.h,state.m));
    updateDisplay();
  }
  function openFor(input){ const cfg=cfgRef(); state.input=input; const cur=parse(input.value)&&parse(input.value) || parse(cfg.start) || {h:6,m:0}; state.h=cur.h; state.m=quantize(cur.m); ({h:state.h,m:state.m}=clamp(state.h,state.m)); updateDisplay(); const r=input.getBoundingClientRect(); root.style.display='block'; root.style.top=window.scrollY + r.bottom + 6 + 'px'; root.style.left=window.scrollX + r.left + 'px'; state.open=true; setTimeout(()=>{ document.addEventListener('mousedown', outside, true); document.addEventListener('keydown', keyNav, true); },0); }
  function close(){ if(!state.open) return; state.open=false; root.style.display='none'; document.removeEventListener('mousedown', outside, true); document.removeEventListener('keydown', keyNav, true); }
  function outside(e){ if(root.contains(e.target) || e.target===state.input) return; close(); }
  function keyNav(e){ if(e.key==='Escape'){ close(); state.input?.focus(); } else if(e.key==='Enter'){ commit(); } }
  function commit(){
    if(!state.input) return;
    const val = fmt(state.h, quantize(state.m));
    state.input.value = val;
    state.input.setAttribute('value', val);
    // Fire both input & change so GHL autosave logic captures value regardless of listener type
    state.input.dispatchEvent(new Event('input',{bubbles:true}));
    state.input.dispatchEvent(new Event('change',{bubbles:true}));
    close();
    window.__singletonTimePicker.suppressNextFocusOpen = true;
    // Blur to finalize; some frameworks persist on blur
    try { state.input.blur(); } catch(_) {}
  }
  root.addEventListener('click', e=>{ const act=e.target.getAttribute('data-act'); if(!act) return; if(act==='hu') adjust(+1,0,false); else if(act==='hd') adjust(-1,0,false); else if(act==='mu') adjust(0,+1,false); else if(act==='md') adjust(0,-1,false); else if(act==='tu'||act==='td') adjust(0,0,true); else if(act==='ok') commit(); else if(act==='x') { close(); state.input?.focus(); } });
  window.__singletonTimePicker = { openFor, close, suppressNextFocusOpen: false };
})();

// Wire one or more pickup time inputs to the singleton picker
window.BookingForm.attachPickupTimePicker = function(rootDoc, specificEl){
  const input = specificEl || rootDoc.querySelector('input[data-q="pickup_time"]');
  if(!input) return;
  if(input.dataset.timeSpinnerWired) return;
  input.dataset.timeSpinnerWired='1';
  input.type='text';
  input.readOnly=true; // prevent mobile keyboard
  input.style.cursor='pointer';
  input.autocomplete='off';
  input.addEventListener('click', ()=> window.__singletonTimePicker.openFor(input));
  input.addEventListener('focus', ()=> {
    if(window.__singletonTimePicker.suppressNextFocusOpen){
      window.__singletonTimePicker.suppressNextFocusOpen = false; // consume flag
      return;
    }
    window.__singletonTimePicker.openFor(input);
  });
};

// Section X: Passenger Count Select (1–15, then 16+) from temp.js

// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

// Section X implementation from temp.js
(function initPassengerSelect(){
  if (window.__passengerSelect) return;

  // Build a <select> to replace the input[data-q="number_of_passengers"]
  function buildSelectFromInput(input){
    const sel = document.createElement('select');

    // carry core attributes so styling/validation behave the same
    sel.name = input.name || 'number_of_passengers';
    sel.setAttribute('data-q', 'number_of_passengers');
    if (input.id) sel.id = input.id;
    if (input.required) sel.required = true;
    sel.className = input.className; // inherit any theme classes

    // --- Placeholder (pulled from the original input, same source as other fields) ---
    const phText = input.getAttribute('placeholder') || 'Number of Passengers';
    const ph = document.createElement('option');
    ph.value = '';
    ph.textContent = phText;
    ph.disabled = true;
    ph.selected = true;
    ph.hidden = true;
    sel.appendChild(ph);

    // --- 1..15 then 16+ ---
    for (let i = 1; i <= 15; i++){
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = String(i);
      sel.appendChild(opt);
    }
    const big = document.createElement('option');
    big.value = '16+';
    big.textContent = '16+';
    sel.appendChild(big);

    // Preserve an existing value if one was already set on the input
    const cur = (input.value || '').trim();
    if ((/^\d+$/.test(cur) && +cur >= 1 && +cur <= 15) || cur === '16+') {
      sel.value = cur;
    }

    // Make the <select> look exactly like the other inputs (font, radius, shadow, etc.)
    window.BookingForm.matchFieldLook(sel);
    
    // Copy the input's current box-shadow & border color, and reuse on focus.
    (function unifyFocusStyles(select){
      const ref = document.querySelector('.icon-field-wrapper input[data-q]') || document.querySelector('input[data-q]');
      if (!ref) return;
      const cs = getComputedStyle(ref);
      const refShadow = cs.boxShadow;
      const refBorder = cs.borderColor;

      // Set baseline to match inputs
      select.style.boxShadow = refShadow;
      select.style.borderColor = refBorder;

      // Reapply on focus to override theme focus rules
      const apply = () => {
        select.style.boxShadow = refShadow;
        select.style.borderColor = refBorder;
        select.style.backgroundColor = '#fff';
      };
      select.addEventListener('focus', apply);
      select.addEventListener('blur', apply);
    })(sel);

    // Placeholder tint handling
    window.BookingForm.applyPlaceholderClass(sel);
    sel.addEventListener('change', () => {
      sel.setAttribute('value', sel.value);
      window.BookingForm.applyPlaceholderClass(sel);
      sel.dispatchEvent(new Event('input', { bubbles: true }));
    });

    return sel;
  }

  function attach(rootDoc){
    const input = rootDoc.querySelector('input[data-q="number_of_passengers"]');
    // If the select already exists, bail
    const selAlready = rootDoc.querySelector('select[data-q="number_of_passengers"]');
    if (!input || selAlready) return;
    if (input.dataset.paxSelectWired === '1') return;

    // Build the select element
    const selectEl = buildSelectFromInput(input);
    
    // Hide the original input but keep it for GoHighLevel survey submission
    input.style.display = 'none';
    input.style.visibility = 'hidden';
    input.style.position = 'absolute';
    input.style.left = '-9999px';
    
    // Ensure the input is marked as important for GHL survey
    input.setAttribute('data-ghl-survey-field', 'true');
    input.setAttribute('data-step-field', 'step1');
    
    // Insert select after the hidden input (don't replace it)
    input.parentNode.insertBefore(selectEl, input.nextSibling);
    
    // Sync select changes back to the hidden input for GHL survey submission
    selectEl.addEventListener('change', () => {
      input.value = selectEl.value;
      selectEl.setAttribute('value', selectEl.value);
      window.BookingForm.applyPlaceholderClass(selectEl);
      
      // Trigger change event on hidden input for GHL survey
      input.dispatchEvent(new Event('change', { bubbles: true }));
      input.dispatchEvent(new Event('input', { bubbles: true }));
      
      // Additional GHL survey events that might be needed
      try {
        input.dispatchEvent(new Event('blur', { bubbles: true }));
        input.dispatchEvent(new CustomEvent('ghl-field-update', { 
          detail: { field: 'number_of_passengers', value: selectEl.value },
          bubbles: true 
        }));
      } catch(e) {
        console.warn('GHL survey event dispatch failed:', e);
      }
      
      selectEl.dispatchEvent(new Event('input', { bubbles: true }));
    });
    
    // Sync input changes back to the select (for URL parameter population)
    input.addEventListener('change', () => {
      if (input.value && input.value !== selectEl.value) {
        selectEl.value = input.value;
        selectEl.setAttribute('value', selectEl.value);
        window.BookingForm.applyPlaceholderClass(selectEl);
      }
    });
    
    // Also sync any initial value from input to select
    if (input.value) {
      selectEl.value = input.value;
      window.BookingForm.applyPlaceholderClass(selectEl);
    }
    
    // Store references for external access and survey step transitions
    input._syncedSelect = selectEl;
    selectEl._syncedInput = input;
    
    selectEl.dataset.paxSelectWired = '1';
    input.dataset.paxSelectWired = '1';

    // Monitor for GHL survey step transitions
    const monitorSurveySteps = () => {
      // Watch for survey navigation buttons
      const nextButtons = document.querySelectorAll('[data-action="next"], .survey-next, .btn-next, button[type="submit"]');
      const prevButtons = document.querySelectorAll('[data-action="prev"], .survey-prev, .btn-prev');
      
      [...nextButtons, ...prevButtons].forEach(btn => {
        if (!btn.dataset.passengerMonitor) {
          btn.addEventListener('click', () => {
            // Ensure passenger field is synced before step transition
            if (selectEl.value && input.value !== selectEl.value) {
              input.value = selectEl.value;
              input.dispatchEvent(new Event('change', { bubbles: true }));
            }
          });
          btn.dataset.passengerMonitor = 'true';
        }
      });
      
      // Watch for survey form submissions
      const forms = document.querySelectorAll('form, .survey-form, .ghl-form');
      forms.forEach(form => {
        if (!form.dataset.passengerMonitor) {
          form.addEventListener('submit', (e) => {
            // Final sync before submission
            if (selectEl.value && input.value !== selectEl.value) {
              input.value = selectEl.value;
            }
          });
          form.dataset.passengerMonitor = 'true';
        }
      });
    };
    
    // Run monitoring immediately and after DOM changes
    monitorSurveySteps();
    setTimeout(monitorSurveySteps, 1000); // Delay for dynamic button creation
    
    // Use MutationObserver to catch dynamically added survey elements
    if (window.MutationObserver) {
      const observer = new MutationObserver((mutations) => {
        let shouldMonitor = false;
        mutations.forEach(mutation => {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === 1 && (
              node.matches && (
                node.matches('button, .btn, .survey-next, .survey-prev') ||
                node.querySelector && node.querySelector('button, .btn, .survey-next, .survey-prev')
              )
            )) {
              shouldMonitor = true;
            }
          });
        });
        if (shouldMonitor) {
          setTimeout(monitorSurveySteps, 100);
        }
      });
      
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      
      // Store observer for cleanup
      selectEl._surveyObserver = observer;
    }

    // Re-run icon wrapper just in case
    try { window.BookingForm.enhanceVisual(document); } catch(_) {}
  }

  window.__passengerSelect = { attach };

  // initial attach
  try { attach(document); } catch(_) {}
})();

// Expose attach function for external use
window.BookingForm.initPassengerSelect = function(root = document) {
  if (window.__passengerSelect && window.__passengerSelect.attach) {
    window.__passengerSelect.attach(root);
  }
};

// Validates step 1 on NEXT (pickup, drop-off, date, time, passengers)
// Adds inline messages and fade-out animation before advancing

// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

window.BookingForm.installStepOneNextValidation = function(){
  if(window.__stepOneNextValidation) return;

  const SELECTORS = [
    'input[data-q="pickup_location"]',
    'input[data-q="drop-off_location"]',
    'input[data-q="pickup_date"]',
    'input[data-q="pickup_time"]',
    'input[data-q="number_of_passengers"]',
    'select[data-q="number_of_passengers"]'
  ];
  const MESSAGES = {
    'pickup_location':'Please enter a pickup location.',
    'drop-off_location':'Please enter a drop-off location.',
    'pickup_date':'Please choose a pickup date.',
    'pickup_time':'Please choose a pickup time.',
    'number_of_passengers':'Please enter the number of passengers.'
  };

  // Find a reasonable container to animate (closest sizable ancestor)
  function findStepContainerFrom(el){
    let node = el.closest?.('.survey-form-step, .ghl-question-set, .hl_form-builder--step, .ghl-form-wrap, form') || el.parentElement;
    let depth = 0;
    while(node && depth < 6){
      try{
        const rect = node.getBoundingClientRect();
        if(rect.height > 120 && node.querySelector?.('input[data-q], .ghl-btn')) return node;
      }catch(_){ /* noop */ }
      node = node.parentElement;
      depth++;
    }
    return document.querySelector('.ghl-question-set') || el.closest?.('form') || document.body;
  }

  // Utility: get visible elements for the provided selectors
  function getVisibleNodes(selectors){
    const nodes = selectors.map(sel => document.querySelector(sel)).filter(Boolean);
    return nodes.filter(el => {
      const s = getComputedStyle(el);
      if(el.disabled || el.type==='hidden' || s.display==='none' || s.visibility==='hidden') return false;
      const r = el.getBoundingClientRect();
      return r.width>0 && r.height>0;
    });
  }

  // Utility: compute the deepest common ancestor that still contains all nodes
  function deepestCommonAncestor(nodes){
    if(!nodes || !nodes.length) return null;
    // Build ancestor chains for each node (upwards to html)
    const chains = nodes.map(n=>{ const path=[]; let x=n; while(x){ path.push(x); x=x.parentElement; } return path; });
    // Start from the first chain, find the first element present in all other chains
    let lca = null;
    outer: for(const candidate of chains[0]){
      for(let i=1;i<chains.length;i++){
        if(!chains[i].includes(candidate)) continue outer;
      }
      lca = candidate; break;
    }
    if(!lca) return null;
    // Walk down while there is exactly one child that contains all nodes
    let curr = lca;
    while(true){
      const children = Array.from(curr.children || []);
      const carriers = children.filter(ch => nodes.every(nd => ch.contains(nd)));
      if(carriers.length === 1){ curr = carriers[0]; } else { break; }
    }
    return curr;
  }

  // Choose the element to animate: prefer the deepest common ancestor within the container
  function pickAnimTarget(container, selectors){
    try{
      const nodes = getVisibleNodes(selectors);
      const dca = deepestCommonAncestor(nodes);
      if(dca && container.contains(dca) && dca !== container) return dca;
    }catch(_){ /* noop */ }
    // Fallback: try common inner wrappers
    const fallback = container.querySelector('.ghl-questions, .ghl-form-rows, .survey-form-content, .survey-form-step .content, .hl_form-builder--step .step-content, .ghl-form-wrap .ghl-content, .ghl-form-container');
    return fallback || container;
  }

  function animateNextThenAdvance(btn){
    if(window.__bfAnimating) return; // avoid overlap
    const container = findStepContainerFrom(btn);
    if(!container){ window.__allowNextOnce = true; setTimeout(()=>btn.click(),0); return; }
    // Animate only the fields area so the outer white background remains
    const animTarget = pickAnimTarget(container, SELECTORS);
    window.__bfAnimating = true;
    animTarget.classList.add('bf-fade-anim');
    // Force reflow before applying out state
    void animTarget.offsetWidth;
    animTarget.classList.add('bf-fade-out');
    // After fade-out, re-trigger the click once (bypassing our guard), then fade-in Step 2
    const DUR = 230;
    setTimeout(()=>{
      // Allow the framework's native action to run once
      window.__allowNextOnce = true;
      // Remove fade-out to prevent lingering style
      animTarget.classList.remove('bf-fade-out');
      animTarget.classList.remove('bf-fade-anim');
      setTimeout(()=>{
        try { btn.click(); } catch(_) {}
        // Try a fade-in on the next step container once it appears
        setTimeout(()=>{
          const STEP2_SELECTORS = [
            'input[data-q="email"]',
            'input[data-q="phone"]',
            'input[data-q="full_name"]'
          ];
          const nextField = document.querySelector(STEP2_SELECTORS.join(', '));
          if(nextField){
            const cont2 = findStepContainerFrom(nextField);
            if(cont2){
              const target2 = pickAnimTarget(cont2, STEP2_SELECTORS);
              target2.classList.add('bf-fade-anim','bf-fade-in-init');
              void target2.offsetWidth; // reflow
              target2.classList.remove('bf-fade-in-init');
              setTimeout(()=> target2.classList.remove('bf-fade-anim'), DUR + 60);
            }
            // Ensure CTA is applied on step 2
            try { enhanceSubmitButton(document); } catch(_) {}
          }
          window.__bfAnimating = false;
        }, 40);
      }, 0);
    }, DUR);
  }

  function isVisible(el){
    if(!el || el.disabled) return false;
    if(el.type === 'hidden') return false;
    const s = getComputedStyle(el);
    if(s.display==='none' || s.visibility==='hidden') return false;
    const rect = el.getBoundingClientRect();
    return rect.width>0 && rect.height>0;
  }

  function ensureMsgNode(container){
    let msg = container.querySelector(':scope > .field-error');
    if(!msg){ msg = document.createElement('div'); msg.className='field-error'; container.appendChild(msg); }
    return msg;
  }

  function showError(el, text){
    try { el.setCustomValidity?.(text); } catch(_) {}
    el.classList.add('input-error');
    el.setAttribute('aria-invalid','true');
    const wrap = el.closest('.icon-field-wrapper');
    const container = wrap || el.parentElement || el;
    // Keep the border only on the input; wrapper is used for shake positioning only
    const msg = ensureMsgNode(container);
    msg.textContent = text;
    container.classList.remove('shake'); void container.offsetWidth; container.classList.add('shake');
    setTimeout(()=> container.classList.remove('shake'), 500);
  }

  function clearError(el){
    try { el.setCustomValidity?.(''); } catch(_) {}
    el.removeAttribute('aria-invalid');
    el.classList.remove('input-error');
    const wrap = el.closest('.icon-field-wrapper');
    const container = wrap || el.parentElement || el;
    const msg = container.querySelector(':scope > .field-error');
    if(msg) msg.textContent = '';
  }

  function hookClearOnInput(el){
    if(el.dataset.step1Wired==='1') return;
    el.dataset.step1Wired='1';
    const h = ()=>{ if((el.value||'').trim()) clearError(el); };
    el.addEventListener('input', h);
    el.addEventListener('change', h);
  }

  function validateStep1(){
    const nodes = SELECTORS.map(sel => document.querySelector(sel)).filter(Boolean);
    let firstInvalid = null;
    for(const el of nodes){
      hookClearOnInput(el);
      if(!isVisible(el)) continue; // ignore hidden in this step
      const v = (el.value||'').trim();
      if(!v){
        const q = el.getAttribute('data-q') || '';
        showError(el, MESSAGES[q] || 'This field is required.');
        if(!firstInvalid) firstInvalid = el;
      } else {
        clearError(el);
      }
    }
    if(firstInvalid){
      try { firstInvalid.scrollIntoView({ behavior:'smooth', block:'center' }); } catch(_) {}
      setTimeout(()=>{ try { firstInvalid.focus({ preventScroll:true }); } catch(_) {} }, 200);
      try { firstInvalid.reportValidity?.(); } catch(_) {}
      return false;
    }
    return true;
  }

  // Delegate click on NEXT buttons so we catch dynamically-rendered ones too
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest?.('.ghl-btn.ghl-footer-next');
    if(!btn) return;
    // One-time bypass to avoid recursion when we re-trigger the click after animation
    if(window.__allowNextOnce){ window.__allowNextOnce = false; return; }
    const ok = validateStep1();
    if(!ok){
      e.preventDefault();
      e.stopPropagation();
    } else {
      // Valid: animate out/in before advancing
      e.preventDefault();
      e.stopPropagation();
      animateNextThenAdvance(btn);
    }
  }, true);

  // Some UIs act on mousedown; intercept that as well
  document.addEventListener('mousedown', (e)=>{
    const btn = e.target.closest?.('.ghl-btn.ghl-footer-next');
    if(!btn) return;
    // One-time bypass for programmatic click
    if(window.__allowNextOnce){ return; }
    if(!validateStep1()){
      e.preventDefault();
      e.stopPropagation();
    } else {
      // Prevent immediate advance; run animation path which will re-fire click
      e.preventDefault();
      e.stopPropagation();
      animateNextThenAdvance(btn);
    }
  }, true);

  window.__stepOneNextValidation = true;
};

// Validates step 2 on SUBMIT (full_name, email, phone)

// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

window.BookingForm.installStepTwoSubmitValidation = function(){
  if(window.__stepTwoSubmitValidation) return;

  const SELECTORS = [
    'input[data-q="email"]',
    'input[data-q="phone"]',
    'input[data-q="full_name"]'
  ];
  const EMPTY_MSG = {
    'email':'Please enter your email address.',
    'phone':'Please enter your phone number.',
    'full_name':'Please enter your full name.'
  };
  const INVALID_MSG = {
    'email':'Please enter a valid email address.'
  };

  function isVisible(el){
    if(!el || el.disabled) return false;
    if(el.type === 'hidden') return false;
    const s = getComputedStyle(el);
    if(s.display==='none' || s.visibility==='hidden') return false;
    const rect = el.getBoundingClientRect();
    return rect.width>0 && rect.height>0;
  }

  function ensureMsgNode(container){
    let msg = container.querySelector(':scope > .field-error');
    if(!msg){ msg = document.createElement('div'); msg.className='field-error'; container.appendChild(msg); }
    return msg;
  }

  function showError(el, text){
    try { el.setCustomValidity?.(text); } catch(_) {}
    el.classList.add('input-error');
    el.setAttribute('aria-invalid','true');
    const wrap = el.closest('.icon-field-wrapper');
    const container = wrap || el.parentElement || el;
    const msg = ensureMsgNode(container);
    msg.textContent = text;
    container.classList.remove('shake'); void container.offsetWidth; container.classList.add('shake');
    setTimeout(()=> container.classList.remove('shake'), 500);
  }

  function clearError(el){
    try { el.setCustomValidity?.(''); } catch(_) {}
    el.removeAttribute('aria-invalid');
    el.classList.remove('input-error');
    const wrap = el.closest('.icon-field-wrapper');
    const container = wrap || el.parentElement || el;
    const msg = container.querySelector(':scope > .field-error');
    if(msg) msg.textContent = '';
  }

  function hookClearOnInput(el){
    if(el.dataset.step2Wired==='1') return;
    el.dataset.step2Wired='1';
    const h = ()=>{ if((el.value||'').trim()) clearError(el); };
    el.addEventListener('input', h);
    el.addEventListener('change', h);
  }

  function validateStep2(){
    const nodes = SELECTORS.map(sel => document.querySelector(sel)).filter(Boolean);
    let firstInvalid = null;
    for(const el of nodes){
      hookClearOnInput(el);
      if(!isVisible(el)) continue; // ignore hidden in other steps
      const q = el.getAttribute('data-q') || '';
      const v = (el.value||'').trim();
      let message = '';
      if(!v){
        message = EMPTY_MSG[q] || 'This field is required.';
      } else if(q==='email' && el.type==='email' && el.validity && el.validity.typeMismatch){
        message = INVALID_MSG[q] || EMPTY_MSG[q];
      }
      if(message){
        showError(el, message);
        if(!firstInvalid) firstInvalid = el;
      } else {
        clearError(el);
      }
    }
    if(firstInvalid){
      try { firstInvalid.scrollIntoView({ behavior:'smooth', block:'center' }); } catch(_) {}
      setTimeout(()=>{ try { firstInvalid.focus({ preventScroll:true }); } catch(_) {} }, 200);
      try { firstInvalid.reportValidity?.(); } catch(_) {}
      return false;
    }
    return true;
  }

  // Intercept SUBMIT button to prevent default top-of-form errors and keep inline messages
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest?.('.ghl-btn.ghl-submit-btn');
    if(!btn) return;
    const ok = validateStep2();
    if(!ok){
      e.preventDefault();
      e.stopPropagation();
    }
  }, true);

  document.addEventListener('mousedown', (e)=>{
    const btn = e.target.closest?.('.ghl-btn.ghl-submit-btn');
    if(!btn) return;
    if(!validateStep2()){
      e.preventDefault();
      e.stopPropagation();
    }
  }, true);

  window.__stepTwoSubmitValidation = true;
};

// Section 10: Maps Initialization + Airport Data + Retry + Prediction Prioritizer from temp.js

// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

// Section 3: Google Maps Loader (dynamic include + readiness poll)
function loadGoogleMaps(callback){
  if (window.google?.maps?.places) return callback();
  
  // Wait for configuration if not ready
  if (!window.BookingForm.configReady) {
    console.log('[Maps] Waiting for configuration...');
    window.BookingForm.onConfigReady = window.BookingForm.onConfigReady || [];
    window.BookingForm.onConfigReady.push(() => loadGoogleMaps(callback));
    return;
  }
  
  if (document.querySelector('script[data-gmaps-loader]')){
    const poll = setInterval(()=>{ if (window.google?.maps?.places){ clearInterval(poll); callback(); } },150);
    setTimeout(()=>clearInterval(poll), window.BookingForm.CONFIG.mapsLoadTimeoutMs);
    return;
  }
  
  const apiKey = window.BookingForm.CONFIG.googleApiKey || window.CFG?.GMAPS_KEY || 'AIzaSyBdVl-cGl0fhXhhD_x5RCJxWQQyzVF0z8g';
  console.log(`[Maps] Loading Google Maps with API key: ${apiKey.substring(0, 10)}...`);
  
  const s = document.createElement('script');
  s.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(apiKey)}&libraries=places`;
  s.async = true; s.defer = true; s.setAttribute('data-gmaps-loader','1');
  s.onload = () => console.log('[Maps] Google Maps loaded successfully');
  s.onerror = () => console.error('[Maps] Failed to load Google Maps JS');
  document.head.appendChild(s);
  const poll = setInterval(()=>{ if (window.google?.maps?.places){ clearInterval(poll); callback(); } },150);
  setTimeout(()=>clearInterval(poll), window.BookingForm.CONFIG.mapsLoadTimeoutMs);
}

// Section 10: Maps Initialization + PAC Filter + Prediction Prioritizer
window.BookingForm.initMapsAndFilters = function() {
  loadGoogleMaps(() => {
    // Build a bias function from config (rectangle OR circle). No geolocation used.
    const biasBoundsFn = (() => {
      const g = google.maps;

      if (window.BookingForm.CONFIG.places.boundsRect) {
        const { sw, ne } = window.BookingForm.CONFIG.places.boundsRect;
        const rect = new g.LatLngBounds(new g.LatLng(sw.lat, sw.lng), new g.LatLng(ne.lat, ne.lng));
        return () => rect;
      }
      if (window.BookingForm.CONFIG.places.biasCircle && Number(window.BookingForm.CONFIG.places.biasCircle.radiusMeters) > 0) {
        const { lat, lng, radiusMeters } = window.BookingForm.CONFIG.places.biasCircle;
        return () => {
          const circle = new g.Circle({
            center: new g.LatLng(lat, lng),
            radius: Number(radiusMeters)
          });
          return circle.getBounds();
        };
      }
      return () => null; // no bias
    })();

    // Set the bias bounds function in autocomplete module (if available)
    if (window.BookingForm.setBiasBoundsFn) {
      window.BookingForm.setBiasBoundsFn(biasBoundsFn);
    }

    // Wire autocomplete (if available)
    if (window.BookingForm.wireAutocomplete) {
      window.BookingForm.wireAutocomplete(document);
    }

    // Retry wiring in case inputs mount after maps load
    (function retryWireAutocomplete(){
      const start = Date.now();
      const intv = setInterval(() => {
        try { 
          if (window.BookingForm.wireAutocomplete) {
            window.BookingForm.wireAutocomplete(document); 
          }
        } catch(_) {}
        const allWired = ['pickup_location','drop-off_location']
          .every(q => document.querySelector(`input[data-q="${q}"]`)?.dataset.placesWired === '1');
        if (allWired || Date.now() - start > 12000) clearInterval(intv);
      }, 450);
    })();
    
    // PAC Filter (hide vague localities/cities)
    (function installPacFilter(){
      if (window.__pacFilterObserver) return;

      const F = window.BookingForm.CONFIG.places.filter || {};
      const airports = (window.BookingForm.CONFIG.places.priorityKeywords?.airport || []).map(s => s.toLowerCase());
      const hotels   = (window.BookingForm.CONFIG.places.priorityKeywords?.hotel   || []).map(s => s.toLowerCase());
      const allowKw  = new Set([...airports, ...hotels, ...(F.allowKeywords || [])]);

      const hasStreetNumber = txt => /\d/.test(txt); // simple and effective
      const hasAllowKeyword = txt => {
        const t = txt.toLowerCase();
        for (const k of allowKw) if (k && t.includes(k)) return true;
        return false;
      };

      function shouldKeep(text){
        // Allow specific addresses or keyword-matching POIs (airports/hotels/etc.)
        if (F.addressMustHaveNumber && hasStreetNumber(text)) return true;
        if (hasAllowKeyword(text)) return true;
        return false;
      }

      function process(container){
        const items = Array.from(container.querySelectorAll('.pac-item'));
        if (!items.length) return;

        // Decide which items to keep by text
        const keep = items.filter(el => shouldKeep(el.textContent || ''));

        // Fail-open: if filtering would wipe out or reduce below minKeep, do nothing.
        const minKeep = Number.isFinite(F.minKeep) ? F.minKeep : 2;
        if (keep.length === 0 || keep.length < minKeep) return;

        // Remove the rest
        const setKeep = new Set(keep);
        items.forEach(el => { if (!setKeep.has(el)) el.remove(); });
      }

      function attach(){
        // Attach to any current and future PAC containers
        document.querySelectorAll('.pac-container').forEach(c => {
          if (c.dataset.pacFilterWired === '1') return;
          const obs = new MutationObserver(() => process(c));
          obs.observe(c, { childList: true, subtree: true });
          c.dataset.pacFilterWired = '1';
        });
      }

      // Initial + focus-driven attach (helps with SPAs / late mounts)
      const hook = () => {
        attach();
        document.addEventListener('focusin', e => {
          if (e.target?.matches?.('input[data-q="pickup_location"], input[data-q="drop-off_location"]')) {
            setTimeout(attach, 0);
          }
        });
      };

      hook();
      window.__pacFilterObserver = true;
    })();

    // Optional re-ranking if you provided PRIORITY_KEYWORDS
    (function installPredictionPriority(){
      if (!window.BookingForm.CONFIG.places.priorityKeywords || window.__predPriorityObserver) return;

      const airports = (window.BookingForm.CONFIG.places.priorityKeywords.airport || []).map(s=>s.toLowerCase());
      const hotels   = (window.BookingForm.CONFIG.places.priorityKeywords.hotel   || []).map(s=>s.toLowerCase());
      const score = (text) => {
        const t = (text || '').toLowerCase();
        if (airports.some(k => t.includes(k))) return 3;
        if (hotels.some(k   => t.includes(k))) return 2;
        return 1;
      };

      function promote(c){
        const items = [...c.querySelectorAll('.pac-item')];
        if (items.length < 2) return;
        const ranked = items.map((el,i)=>({el,i,s:score(el.textContent)}))
                            .sort((a,b)=> (b.s-a.s) || (a.i-b.i));
        let changed = ranked.some((r, i) => r.el !== items[i]);
        if (!changed) return;
        const frag = document.createDocumentFragment();
        ranked.forEach(r => frag.appendChild(r.el));
        c.appendChild(frag);
      }

      const attach = () => {
        const c = document.querySelector('.pac-container');
        if (!c){ setTimeout(attach, 250); return; }
        const obs = new MutationObserver(() => promote(c));
        obs.observe(c, { childList:true, subtree:false });
        window.__predPriorityObserver = obs;
      };
      attach();
    })();
  });
};

// Expose loadGoogleMaps function for backwards compatibility
window.BookingForm.loadGoogleMaps = loadGoogleMaps;// Google Places Autocomplete + Airport Code Normalization (Section 6)

// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

// Section 6 implementation from temp.js
function normalizeSafely(el, obs){
  if (obs) obs.disconnect();
  el.classList.remove('pac-target-input','disabled','is-disabled');
  el.removeAttribute('readonly');
  if (el.getAttribute('aria-disabled') === 'true') el.removeAttribute('aria-disabled');
  if (el.getAttribute('autocomplete') !== 'on') el.setAttribute('autocomplete','on');
  if (el.style.opacity) el.style.opacity='';
  if (obs) obs.observe(el,{attributes:true,attributeFilter:['class','readonly','aria-disabled','autocomplete','style'],attributeOldValue:true});
}

let biasBoundsFn = null;

function wireAutocomplete(rootDoc){
  if (!window.google?.maps?.places) return;

  const sels = ['input[data-q="pickup_location"]','input[data-q="drop-off_location"]'];

  for (const sel of sels){
    const els = [...rootDoc.querySelectorAll(sel)];
    for (const el of els){
      if (!el || el.dataset.placesWired === '1') continue;

      const cs = getComputedStyle(el);
      if (el.type === 'hidden' || cs.display === 'none' || cs.visibility === 'hidden') continue;

      el.dataset.placesWired = '1';

      const acOpts = {
        fields: window.BookingForm.CONFIG.places.fields,
        types:  window.BookingForm.getAutocompleteTypesFromConfig()
      };

      const b = biasBoundsFn?.();
      if (b) { acOpts.bounds = b; acOpts.strictBounds = true; }

      if (window.BookingForm.CONFIG.countries?.length) {
        acOpts.componentRestrictions = { country: window.BookingForm.CONFIG.countries };
      }

      let ac;
      try {
        ac = new google.maps.places.Autocomplete(el, acOpts);
      } catch (err) {
        console.error('[Maps] Autocomplete init failed:', err);
        continue;
      }

      ac.addListener('place_changed', () => {
        const place = ac.getPlace();
        if (!place?.place_id || !place.geometry) return;

        const isAirport = (place.types || []).includes('airport');
        const AIRPORT_CODES = window.BookingForm.CONFIG.places.airportCodes;
        let display = '';
        if (isAirport && place.name){
          const code = AIRPORT_CODES[place.name];
          display = code ? `${place.name} (${code})` : place.name;
        } else if (place.name){
          display = place.name;
        } else if (place.formatted_address){
          display = place.formatted_address;
        }

        setTimeout(() => {
          el.value = display;
          el.setAttribute('value', display);
          el.dispatchEvent(new Event('input', { bubbles:true }));
          el.dispatchEvent(new Event('change', { bubbles:true }));
          document.documentElement.classList.add('pac-hide');
          setTimeout(() => document.documentElement.classList.remove('pac-hide'), 700);
          try { el.blur(); } catch(_) {}
          try { el.dispatchEvent(new KeyboardEvent('keydown', { key:'Escape', bubbles:true })); } catch(_) {}
          (document.querySelector('input[data-q="drop-off_location"]')
            || document.querySelector('input[data-q="pickup_date"]')
            || document.querySelector('input[data-q="pickup_time"]'))?.focus();
          const hide = () => document.querySelectorAll('.pac-container').forEach(pc => pc.style.display='none');
          [0,30,80,160,300].forEach(d => setTimeout(hide, d));
        }, 0);
      });

      el.addEventListener('focus', () => {
        try { const nb = biasBoundsFn?.(); if (nb) ac.setBounds(nb); } catch(_) {}
      }, { once:true });

      let obs;
      obs = new MutationObserver(() => normalizeSafely(el, obs));
      normalizeSafely(el, obs);
    }
  }
}

// Expose wireAutocomplete function and biasBoundsFn for external setup
window.BookingForm.wireAutocomplete = wireAutocomplete;
window.BookingForm.setBiasBoundsFn = function(fn) { biasBoundsFn = fn; };// Section 9: Dynamic Field Observer (MutationObserver) from temp.js

// Global namespace for booking form
window.BookingForm = window.BookingForm || {};

// Section 9 implementation from temp.js
(function observeLateFields(){
  if(window.__iconFieldObserver) return;
  const targetAttrs=['pickup_location','drop-off_location','pickup_date','pickup_time','number_of_passengers','full_name','email','phone'];
  const obs=new MutationObserver(muts=>{
    for(const m of muts){
      m.addedNodes && m.addedNodes.forEach(node=>{
        if(!(node instanceof HTMLElement)) return;
        const candidates = node.matches?.('input,select') ? [node] : [...node.querySelectorAll?.('input,select')||[]];
        candidates.forEach(el=>{
          const q=el.getAttribute('data-q');
          if(q && targetAttrs.includes(q)){
            // Re-run visual enhancement only for the specific element
            window.BookingForm.enhanceVisual(document); // idempotent
            window.BookingForm.enhanceNextButtonMobile(document);
            // Ensure CTA is applied if submit button renders late
            window.BookingForm.enhanceSubmitButton(document);
            // If a location field appears after initial maps load, try wiring autocomplete immediately.
            if ((q==='pickup_location' || q==='drop-off_location') && window.google?.maps?.places) {
              try { window.BookingForm.wireAutocomplete(document); } catch(e){ /* noop */ }
            }
            if(q==='pickup_date'){
              // Re-apply date guard for replaced/late field, preserve vertical metrics
              try { window.BookingForm.attachPickupDateGuard(document); } catch(_) {}
              try { window.__pickupDatePicker?.attach(document); } catch(_) {}
            }
            if(q==='pickup_time'){
              try { window.BookingForm.attachPickupTimePicker(document, el); } catch(_){}
            }
            if(q==='number_of_passengers'){
              try { window.__passengerSelect?.attach(document); } catch(_) {}
            }
          }
        });
        // Also check if a submit button was inserted
        if(node.matches?.('.ghl-btn.ghl-submit-btn') || node.querySelector?.('.ghl-btn.ghl-submit-btn')){
          window.BookingForm.enhanceSubmitButton(document);
        }
        // Also check if a NEXT button was inserted
        if(node.matches?.('.ghl-btn.ghl-footer-next') || node.querySelector?.('.ghl-btn.ghl-footer-next')){
          window.BookingForm.enhanceNextButtonMobile(document);
        }
      });
    }
  });
  obs.observe(document.documentElement,{subtree:true,childList:true});
  window.__iconFieldObserver=obs;
})();

// Expose observeLateFields function for external use
window.BookingForm.observeLateFields = function(){
  // The IIFE above handles the singleton pattern, so this is just for API consistency
  return window.__iconFieldObserver;
};
// Essential initialization code
window.BookingForm.initNow = function(root = document) {
  // Section 1 & 2: Inject essential styles first
  window.BookingForm.injectBaselineStyles();
  window.BookingForm.injectValidationStyles();
};

// Section 8: Form Enhancement Function (called after config is loaded)
window.BookingForm.enhance = function() {
  console.log('[BookingForm] Starting form enhancement...');
  
    // Apply tour-specific behavior if detected (re-apply in case form loaded late)
    if (window.CFG?.tourPageDetected) {
      console.log('[BookingForm] Re-applying tour page behavior during enhancement...');
      applyTourPageBehavior();
    }
    
    // Purpose: Kick off date guard, time picker wiring, and icon injection for elements already in DOM.
    // Adjust order only if dependencies change (icons don't depend on others).
    
    window.BookingForm.attachPickupDateGuard(document);
    window.BookingForm.attachPickupTimePicker(document);
    window.BookingForm.enhanceVisual(document);
    window.BookingForm.enhanceNextButtonMobile(document);
    window.BookingForm.enhanceSubmitButton(document);
    window.BookingForm.initSurveyTransitions(document);
    
    // Install validation for both steps
    window.BookingForm.installStepOneNextValidation();
    window.BookingForm.installStepTwoSubmitValidation();
    
    // Secondary run to catch late-rendered inputs
    setTimeout(()=>{
      window.BookingForm.enhanceVisual(document);
    },400);

    // Section 10: Initialize Google Maps, autocomplete, PAC filters, and prediction prioritizer
    window.BookingForm.initMapsAndFilters();

    // Watch for late-rendered/replaced fields (GHL)
    window.BookingForm.observeLateFields();

    console.log('[BookingForm] Form enhancement complete');
};

// Note: Form enhancement is called by async-config-loader.js after config loads
